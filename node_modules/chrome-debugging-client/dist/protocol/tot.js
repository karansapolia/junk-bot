"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class Inspector {
    constructor(client) {
        this._detached = null;
        this._targetCrashed = null;
        this._client = client;
    }
    /** Enables inspector domain notifications. */
    enable() {
        return this._client.send("Inspector.enable");
    }
    /** Disables inspector domain notifications. */
    disable() {
        return this._client.send("Inspector.disable");
    }
    /** Fired when remote debugging connection is about to be terminated. Contains detach reason. */
    get detached() {
        return this._detached;
    }
    set detached(handler) {
        if (this._detached) {
            this._client.removeListener("Inspector.detached", this._detached);
        }
        this._detached = handler;
        if (handler) {
            this._client.on("Inspector.detached", handler);
        }
    }
    /** Fired when debugging target has crashed */
    get targetCrashed() {
        return this._targetCrashed;
    }
    set targetCrashed(handler) {
        if (this._targetCrashed) {
            this._client.removeListener("Inspector.targetCrashed", this._targetCrashed);
        }
        this._targetCrashed = handler;
        if (handler) {
            this._client.on("Inspector.targetCrashed", handler);
        }
    }
}
exports.Inspector = Inspector;
class Memory {
    constructor(client) {
        this._client = client;
    }
    getDOMCounters() {
        return this._client.send("Memory.getDOMCounters");
    }
    prepareForLeakDetection() {
        return this._client.send("Memory.prepareForLeakDetection");
    }
    /** Enable/disable suppressing memory pressure notifications in all processes. */
    setPressureNotificationsSuppressed(params) {
        return this._client.send("Memory.setPressureNotificationsSuppressed", params);
    }
    /** Simulate a memory pressure notification in all processes. */
    simulatePressureNotification(params) {
        return this._client.send("Memory.simulatePressureNotification", params);
    }
}
exports.Memory = Memory;
class Performance {
    constructor(client) {
        this._metrics = null;
        this._client = client;
    }
    /** Enable collecting and reporting metrics. */
    enable() {
        return this._client.send("Performance.enable");
    }
    /** Disable collecting and reporting metrics. */
    disable() {
        return this._client.send("Performance.disable");
    }
    /** Retrieve current values of run-time metrics. */
    getMetrics() {
        return this._client.send("Performance.getMetrics");
    }
    /** Current values of the metrics. */
    get metrics() {
        return this._metrics;
    }
    set metrics(handler) {
        if (this._metrics) {
            this._client.removeListener("Performance.metrics", this._metrics);
        }
        this._metrics = handler;
        if (handler) {
            this._client.on("Performance.metrics", handler);
        }
    }
}
exports.Performance = Performance;
/** Actions and events related to the inspected page belong to the page domain. */
class Page {
    constructor(client) {
        this._domContentEventFired = null;
        this._loadEventFired = null;
        this._lifecycleEvent = null;
        this._frameAttached = null;
        this._frameNavigated = null;
        this._frameDetached = null;
        this._frameStartedLoading = null;
        this._frameStoppedLoading = null;
        this._frameScheduledNavigation = null;
        this._frameClearedScheduledNavigation = null;
        this._frameResized = null;
        this._javascriptDialogOpening = null;
        this._javascriptDialogClosed = null;
        this._screencastFrame = null;
        this._screencastVisibilityChanged = null;
        this._interstitialShown = null;
        this._interstitialHidden = null;
        this._windowOpen = null;
        this._client = client;
    }
    /** Enables page domain notifications. */
    enable() {
        return this._client.send("Page.enable");
    }
    /** Disables page domain notifications. */
    disable() {
        return this._client.send("Page.disable");
    }
    /** Deprecated, please use addScriptToEvaluateOnNewDocument instead. */
    addScriptToEvaluateOnLoad(params) {
        return this._client.send("Page.addScriptToEvaluateOnLoad", params);
    }
    /** Deprecated, please use removeScriptToEvaluateOnNewDocument instead. */
    removeScriptToEvaluateOnLoad(params) {
        return this._client.send("Page.removeScriptToEvaluateOnLoad", params);
    }
    /** Evaluates given script in every frame upon creation (before loading frame's scripts). */
    addScriptToEvaluateOnNewDocument(params) {
        return this._client.send("Page.addScriptToEvaluateOnNewDocument", params);
    }
    /** Removes given script from the list. */
    removeScriptToEvaluateOnNewDocument(params) {
        return this._client.send("Page.removeScriptToEvaluateOnNewDocument", params);
    }
    /** Controls whether browser will open a new inspector window for connected pages. */
    setAutoAttachToCreatedPages(params) {
        return this._client.send("Page.setAutoAttachToCreatedPages", params);
    }
    /** Controls whether page will emit lifecycle events. */
    setLifecycleEventsEnabled(params) {
        return this._client.send("Page.setLifecycleEventsEnabled", params);
    }
    /** Reloads given page optionally ignoring the cache. */
    reload(params) {
        return this._client.send("Page.reload", params);
    }
    /** Enable Chrome's experimental ad filter on all sites. */
    setAdBlockingEnabled(params) {
        return this._client.send("Page.setAdBlockingEnabled", params);
    }
    /** Navigates current page to the given URL. */
    navigate(params) {
        return this._client.send("Page.navigate", params);
    }
    /** Force the page stop all navigations and pending resource fetches. */
    stopLoading() {
        return this._client.send("Page.stopLoading");
    }
    /** Returns navigation history for the current page. */
    getNavigationHistory() {
        return this._client.send("Page.getNavigationHistory");
    }
    /** Navigates current page to the given history entry. */
    navigateToHistoryEntry(params) {
        return this._client.send("Page.navigateToHistoryEntry", params);
    }
    /** Returns all browser cookies. Depending on the backend support, will return detailed cookie information in the <code>cookies</code> field. */
    getCookies() {
        return this._client.send("Page.getCookies");
    }
    /** Deletes browser cookie with given name, domain and path. */
    deleteCookie(params) {
        return this._client.send("Page.deleteCookie", params);
    }
    /** Returns present frame / resource tree structure. */
    getResourceTree() {
        return this._client.send("Page.getResourceTree");
    }
    /** Returns present frame tree structure. */
    getFrameTree() {
        return this._client.send("Page.getFrameTree");
    }
    /** Returns content of the given resource. */
    getResourceContent(params) {
        return this._client.send("Page.getResourceContent", params);
    }
    /** Searches for given string in resource content. */
    searchInResource(params) {
        return this._client.send("Page.searchInResource", params);
    }
    /** Sets given markup as the document's HTML. */
    setDocumentContent(params) {
        return this._client.send("Page.setDocumentContent", params);
    }
    /** Overrides the values of device screen dimensions (window.screen.width, window.screen.height, window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media query results). */
    setDeviceMetricsOverride(params) {
        return this._client.send("Page.setDeviceMetricsOverride", params);
    }
    /** Clears the overriden device metrics. */
    clearDeviceMetricsOverride() {
        return this._client.send("Page.clearDeviceMetricsOverride");
    }
    /** Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position unavailable. */
    setGeolocationOverride(params) {
        return this._client.send("Page.setGeolocationOverride", params);
    }
    /** Clears the overriden Geolocation Position and Error. */
    clearGeolocationOverride() {
        return this._client.send("Page.clearGeolocationOverride");
    }
    /** Overrides the Device Orientation. */
    setDeviceOrientationOverride(params) {
        return this._client.send("Page.setDeviceOrientationOverride", params);
    }
    /** Clears the overridden Device Orientation. */
    clearDeviceOrientationOverride() {
        return this._client.send("Page.clearDeviceOrientationOverride");
    }
    /** Toggles mouse event-based touch event emulation. */
    setTouchEmulationEnabled(params) {
        return this._client.send("Page.setTouchEmulationEnabled", params);
    }
    /** Capture page screenshot. */
    captureScreenshot(params) {
        return this._client.send("Page.captureScreenshot", params);
    }
    /** Print page as PDF. */
    printToPDF(params) {
        return this._client.send("Page.printToPDF", params);
    }
    /** Starts sending each frame using the <code>screencastFrame</code> event. */
    startScreencast(params) {
        return this._client.send("Page.startScreencast", params);
    }
    /** Stops sending each frame in the <code>screencastFrame</code>. */
    stopScreencast() {
        return this._client.send("Page.stopScreencast");
    }
    /** Acknowledges that a screencast frame has been received by the frontend. */
    screencastFrameAck(params) {
        return this._client.send("Page.screencastFrameAck", params);
    }
    /** Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload). */
    handleJavaScriptDialog(params) {
        return this._client.send("Page.handleJavaScriptDialog", params);
    }
    getAppManifest() {
        return this._client.send("Page.getAppManifest");
    }
    requestAppBanner() {
        return this._client.send("Page.requestAppBanner");
    }
    /** Returns metrics relating to the layouting of the page, such as viewport bounds/scale. */
    getLayoutMetrics() {
        return this._client.send("Page.getLayoutMetrics");
    }
    /** Creates an isolated world for the given frame. */
    createIsolatedWorld(params) {
        return this._client.send("Page.createIsolatedWorld", params);
    }
    /** Brings page to front (activates tab). */
    bringToFront() {
        return this._client.send("Page.bringToFront");
    }
    /** Set the behavior when downloading a file. */
    setDownloadBehavior(params) {
        return this._client.send("Page.setDownloadBehavior", params);
    }
    get domContentEventFired() {
        return this._domContentEventFired;
    }
    set domContentEventFired(handler) {
        if (this._domContentEventFired) {
            this._client.removeListener("Page.domContentEventFired", this._domContentEventFired);
        }
        this._domContentEventFired = handler;
        if (handler) {
            this._client.on("Page.domContentEventFired", handler);
        }
    }
    get loadEventFired() {
        return this._loadEventFired;
    }
    set loadEventFired(handler) {
        if (this._loadEventFired) {
            this._client.removeListener("Page.loadEventFired", this._loadEventFired);
        }
        this._loadEventFired = handler;
        if (handler) {
            this._client.on("Page.loadEventFired", handler);
        }
    }
    /** Fired for top level page lifecycle events such as navigation, load, paint, etc. */
    get lifecycleEvent() {
        return this._lifecycleEvent;
    }
    set lifecycleEvent(handler) {
        if (this._lifecycleEvent) {
            this._client.removeListener("Page.lifecycleEvent", this._lifecycleEvent);
        }
        this._lifecycleEvent = handler;
        if (handler) {
            this._client.on("Page.lifecycleEvent", handler);
        }
    }
    /** Fired when frame has been attached to its parent. */
    get frameAttached() {
        return this._frameAttached;
    }
    set frameAttached(handler) {
        if (this._frameAttached) {
            this._client.removeListener("Page.frameAttached", this._frameAttached);
        }
        this._frameAttached = handler;
        if (handler) {
            this._client.on("Page.frameAttached", handler);
        }
    }
    /** Fired once navigation of the frame has completed. Frame is now associated with the new loader. */
    get frameNavigated() {
        return this._frameNavigated;
    }
    set frameNavigated(handler) {
        if (this._frameNavigated) {
            this._client.removeListener("Page.frameNavigated", this._frameNavigated);
        }
        this._frameNavigated = handler;
        if (handler) {
            this._client.on("Page.frameNavigated", handler);
        }
    }
    /** Fired when frame has been detached from its parent. */
    get frameDetached() {
        return this._frameDetached;
    }
    set frameDetached(handler) {
        if (this._frameDetached) {
            this._client.removeListener("Page.frameDetached", this._frameDetached);
        }
        this._frameDetached = handler;
        if (handler) {
            this._client.on("Page.frameDetached", handler);
        }
    }
    /** Fired when frame has started loading. */
    get frameStartedLoading() {
        return this._frameStartedLoading;
    }
    set frameStartedLoading(handler) {
        if (this._frameStartedLoading) {
            this._client.removeListener("Page.frameStartedLoading", this._frameStartedLoading);
        }
        this._frameStartedLoading = handler;
        if (handler) {
            this._client.on("Page.frameStartedLoading", handler);
        }
    }
    /** Fired when frame has stopped loading. */
    get frameStoppedLoading() {
        return this._frameStoppedLoading;
    }
    set frameStoppedLoading(handler) {
        if (this._frameStoppedLoading) {
            this._client.removeListener("Page.frameStoppedLoading", this._frameStoppedLoading);
        }
        this._frameStoppedLoading = handler;
        if (handler) {
            this._client.on("Page.frameStoppedLoading", handler);
        }
    }
    /** Fired when frame schedules a potential navigation. */
    get frameScheduledNavigation() {
        return this._frameScheduledNavigation;
    }
    set frameScheduledNavigation(handler) {
        if (this._frameScheduledNavigation) {
            this._client.removeListener("Page.frameScheduledNavigation", this._frameScheduledNavigation);
        }
        this._frameScheduledNavigation = handler;
        if (handler) {
            this._client.on("Page.frameScheduledNavigation", handler);
        }
    }
    /** Fired when frame no longer has a scheduled navigation. */
    get frameClearedScheduledNavigation() {
        return this._frameClearedScheduledNavigation;
    }
    set frameClearedScheduledNavigation(handler) {
        if (this._frameClearedScheduledNavigation) {
            this._client.removeListener("Page.frameClearedScheduledNavigation", this._frameClearedScheduledNavigation);
        }
        this._frameClearedScheduledNavigation = handler;
        if (handler) {
            this._client.on("Page.frameClearedScheduledNavigation", handler);
        }
    }
    get frameResized() {
        return this._frameResized;
    }
    set frameResized(handler) {
        if (this._frameResized) {
            this._client.removeListener("Page.frameResized", this._frameResized);
        }
        this._frameResized = handler;
        if (handler) {
            this._client.on("Page.frameResized", handler);
        }
    }
    /** Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) is about to open. */
    get javascriptDialogOpening() {
        return this._javascriptDialogOpening;
    }
    set javascriptDialogOpening(handler) {
        if (this._javascriptDialogOpening) {
            this._client.removeListener("Page.javascriptDialogOpening", this._javascriptDialogOpening);
        }
        this._javascriptDialogOpening = handler;
        if (handler) {
            this._client.on("Page.javascriptDialogOpening", handler);
        }
    }
    /** Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) has been closed. */
    get javascriptDialogClosed() {
        return this._javascriptDialogClosed;
    }
    set javascriptDialogClosed(handler) {
        if (this._javascriptDialogClosed) {
            this._client.removeListener("Page.javascriptDialogClosed", this._javascriptDialogClosed);
        }
        this._javascriptDialogClosed = handler;
        if (handler) {
            this._client.on("Page.javascriptDialogClosed", handler);
        }
    }
    /** Compressed image data requested by the <code>startScreencast</code>. */
    get screencastFrame() {
        return this._screencastFrame;
    }
    set screencastFrame(handler) {
        if (this._screencastFrame) {
            this._client.removeListener("Page.screencastFrame", this._screencastFrame);
        }
        this._screencastFrame = handler;
        if (handler) {
            this._client.on("Page.screencastFrame", handler);
        }
    }
    /** Fired when the page with currently enabled screencast was shown or hidden </code>. */
    get screencastVisibilityChanged() {
        return this._screencastVisibilityChanged;
    }
    set screencastVisibilityChanged(handler) {
        if (this._screencastVisibilityChanged) {
            this._client.removeListener("Page.screencastVisibilityChanged", this._screencastVisibilityChanged);
        }
        this._screencastVisibilityChanged = handler;
        if (handler) {
            this._client.on("Page.screencastVisibilityChanged", handler);
        }
    }
    /** Fired when interstitial page was shown */
    get interstitialShown() {
        return this._interstitialShown;
    }
    set interstitialShown(handler) {
        if (this._interstitialShown) {
            this._client.removeListener("Page.interstitialShown", this._interstitialShown);
        }
        this._interstitialShown = handler;
        if (handler) {
            this._client.on("Page.interstitialShown", handler);
        }
    }
    /** Fired when interstitial page was hidden */
    get interstitialHidden() {
        return this._interstitialHidden;
    }
    set interstitialHidden(handler) {
        if (this._interstitialHidden) {
            this._client.removeListener("Page.interstitialHidden", this._interstitialHidden);
        }
        this._interstitialHidden = handler;
        if (handler) {
            this._client.on("Page.interstitialHidden", handler);
        }
    }
    /** Fired when a new window is going to be opened, via window.open(), link click, form submission, etc. */
    get windowOpen() {
        return this._windowOpen;
    }
    set windowOpen(handler) {
        if (this._windowOpen) {
            this._client.removeListener("Page.windowOpen", this._windowOpen);
        }
        this._windowOpen = handler;
        if (handler) {
            this._client.on("Page.windowOpen", handler);
        }
    }
}
exports.Page = Page;
/** This domain provides various functionality related to drawing atop the inspected page. */
class Overlay {
    constructor(client) {
        this._nodeHighlightRequested = null;
        this._inspectNodeRequested = null;
        this._screenshotRequested = null;
        this._client = client;
    }
    /** Enables domain notifications. */
    enable() {
        return this._client.send("Overlay.enable");
    }
    /** Disables domain notifications. */
    disable() {
        return this._client.send("Overlay.disable");
    }
    /** Requests that backend shows paint rectangles */
    setShowPaintRects(params) {
        return this._client.send("Overlay.setShowPaintRects", params);
    }
    /** Requests that backend shows debug borders on layers */
    setShowDebugBorders(params) {
        return this._client.send("Overlay.setShowDebugBorders", params);
    }
    /** Requests that backend shows the FPS counter */
    setShowFPSCounter(params) {
        return this._client.send("Overlay.setShowFPSCounter", params);
    }
    /** Requests that backend shows scroll bottleneck rects */
    setShowScrollBottleneckRects(params) {
        return this._client.send("Overlay.setShowScrollBottleneckRects", params);
    }
    /** Paints viewport size upon main frame resize. */
    setShowViewportSizeOnResize(params) {
        return this._client.send("Overlay.setShowViewportSizeOnResize", params);
    }
    setPausedInDebuggerMessage(params) {
        return this._client.send("Overlay.setPausedInDebuggerMessage", params);
    }
    setSuspended(params) {
        return this._client.send("Overlay.setSuspended", params);
    }
    /** Enters the 'inspect' mode. In this mode, elements that user is hovering over are highlighted. Backend then generates 'inspectNodeRequested' event upon element selection. */
    setInspectMode(params) {
        return this._client.send("Overlay.setInspectMode", params);
    }
    /** Highlights given rectangle. Coordinates are absolute with respect to the main frame viewport. */
    highlightRect(params) {
        return this._client.send("Overlay.highlightRect", params);
    }
    /** Highlights given quad. Coordinates are absolute with respect to the main frame viewport. */
    highlightQuad(params) {
        return this._client.send("Overlay.highlightQuad", params);
    }
    /** Highlights DOM node with given id or with the given JavaScript object wrapper. Either nodeId or objectId must be specified. */
    highlightNode(params) {
        return this._client.send("Overlay.highlightNode", params);
    }
    /** Highlights owner element of the frame with given id. */
    highlightFrame(params) {
        return this._client.send("Overlay.highlightFrame", params);
    }
    /** Hides any highlight. */
    hideHighlight() {
        return this._client.send("Overlay.hideHighlight");
    }
    /** For testing. */
    getHighlightObjectForTest(params) {
        return this._client.send("Overlay.getHighlightObjectForTest", params);
    }
    /** Fired when the node should be highlighted. This happens after call to <code>setInspectMode</code>. */
    get nodeHighlightRequested() {
        return this._nodeHighlightRequested;
    }
    set nodeHighlightRequested(handler) {
        if (this._nodeHighlightRequested) {
            this._client.removeListener("Overlay.nodeHighlightRequested", this._nodeHighlightRequested);
        }
        this._nodeHighlightRequested = handler;
        if (handler) {
            this._client.on("Overlay.nodeHighlightRequested", handler);
        }
    }
    /** Fired when the node should be inspected. This happens after call to <code>setInspectMode</code> or when user manually inspects an element. */
    get inspectNodeRequested() {
        return this._inspectNodeRequested;
    }
    set inspectNodeRequested(handler) {
        if (this._inspectNodeRequested) {
            this._client.removeListener("Overlay.inspectNodeRequested", this._inspectNodeRequested);
        }
        this._inspectNodeRequested = handler;
        if (handler) {
            this._client.on("Overlay.inspectNodeRequested", handler);
        }
    }
    /** Fired when user asks to capture screenshot of some area on the page. */
    get screenshotRequested() {
        return this._screenshotRequested;
    }
    set screenshotRequested(handler) {
        if (this._screenshotRequested) {
            this._client.removeListener("Overlay.screenshotRequested", this._screenshotRequested);
        }
        this._screenshotRequested = handler;
        if (handler) {
            this._client.on("Overlay.screenshotRequested", handler);
        }
    }
}
exports.Overlay = Overlay;
/** This domain emulates different environments for the page. */
class Emulation {
    constructor(client) {
        this._virtualTimeBudgetExpired = null;
        this._virtualTimeAdvanced = null;
        this._virtualTimePaused = null;
        this._client = client;
    }
    /** Overrides the values of device screen dimensions (window.screen.width, window.screen.height, window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media query results). */
    setDeviceMetricsOverride(params) {
        return this._client.send("Emulation.setDeviceMetricsOverride", params);
    }
    /** Clears the overriden device metrics. */
    clearDeviceMetricsOverride() {
        return this._client.send("Emulation.clearDeviceMetricsOverride");
    }
    /** Requests that page scale factor is reset to initial values. */
    resetPageScaleFactor() {
        return this._client.send("Emulation.resetPageScaleFactor");
    }
    /** Sets a specified page scale factor. */
    setPageScaleFactor(params) {
        return this._client.send("Emulation.setPageScaleFactor", params);
    }
    /** Resizes the frame/viewport of the page. Note that this does not affect the frame's container (e.g. browser window). Can be used to produce screenshots of the specified size. Not supported on Android. */
    setVisibleSize(params) {
        return this._client.send("Emulation.setVisibleSize", params);
    }
    /** Switches script execution in the page. */
    setScriptExecutionDisabled(params) {
        return this._client.send("Emulation.setScriptExecutionDisabled", params);
    }
    /** Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position unavailable. */
    setGeolocationOverride(params) {
        return this._client.send("Emulation.setGeolocationOverride", params);
    }
    /** Clears the overriden Geolocation Position and Error. */
    clearGeolocationOverride() {
        return this._client.send("Emulation.clearGeolocationOverride");
    }
    /** Enables touch on platforms which do not support them. */
    setTouchEmulationEnabled(params) {
        return this._client.send("Emulation.setTouchEmulationEnabled", params);
    }
    setEmitTouchEventsForMouse(params) {
        return this._client.send("Emulation.setEmitTouchEventsForMouse", params);
    }
    /** Emulates the given media for CSS media queries. */
    setEmulatedMedia(params) {
        return this._client.send("Emulation.setEmulatedMedia", params);
    }
    /** Enables CPU throttling to emulate slow CPUs. */
    setCPUThrottlingRate(params) {
        return this._client.send("Emulation.setCPUThrottlingRate", params);
    }
    /** Tells whether emulation is supported. */
    canEmulate() {
        return this._client.send("Emulation.canEmulate");
    }
    /** Turns on virtual time for all frames (replacing real-time with a synthetic time source) and sets the current virtual time policy.  Note this supersedes any previous time budget. */
    setVirtualTimePolicy(params) {
        return this._client.send("Emulation.setVirtualTimePolicy", params);
    }
    /** Overrides value returned by the javascript navigator object. */
    setNavigatorOverrides(params) {
        return this._client.send("Emulation.setNavigatorOverrides", params);
    }
    /** Sets or clears an override of the default background color of the frame. This override is used if the content does not specify one. */
    setDefaultBackgroundColorOverride(params) {
        return this._client.send("Emulation.setDefaultBackgroundColorOverride", params);
    }
    /** Notification sent after the virtual time budget for the current VirtualTimePolicy has run out. */
    get virtualTimeBudgetExpired() {
        return this._virtualTimeBudgetExpired;
    }
    set virtualTimeBudgetExpired(handler) {
        if (this._virtualTimeBudgetExpired) {
            this._client.removeListener("Emulation.virtualTimeBudgetExpired", this._virtualTimeBudgetExpired);
        }
        this._virtualTimeBudgetExpired = handler;
        if (handler) {
            this._client.on("Emulation.virtualTimeBudgetExpired", handler);
        }
    }
    /** Notification sent after the virtual time has advanced. */
    get virtualTimeAdvanced() {
        return this._virtualTimeAdvanced;
    }
    set virtualTimeAdvanced(handler) {
        if (this._virtualTimeAdvanced) {
            this._client.removeListener("Emulation.virtualTimeAdvanced", this._virtualTimeAdvanced);
        }
        this._virtualTimeAdvanced = handler;
        if (handler) {
            this._client.on("Emulation.virtualTimeAdvanced", handler);
        }
    }
    /** Notification sent after the virtual time has paused. */
    get virtualTimePaused() {
        return this._virtualTimePaused;
    }
    set virtualTimePaused(handler) {
        if (this._virtualTimePaused) {
            this._client.removeListener("Emulation.virtualTimePaused", this._virtualTimePaused);
        }
        this._virtualTimePaused = handler;
        if (handler) {
            this._client.on("Emulation.virtualTimePaused", handler);
        }
    }
}
exports.Emulation = Emulation;
/** Security */
class Security {
    constructor(client) {
        this._securityStateChanged = null;
        this._certificateError = null;
        this._client = client;
    }
    /** Enables tracking security state changes. */
    enable() {
        return this._client.send("Security.enable");
    }
    /** Disables tracking security state changes. */
    disable() {
        return this._client.send("Security.disable");
    }
    /** Handles a certificate error that fired a certificateError event. */
    handleCertificateError(params) {
        return this._client.send("Security.handleCertificateError", params);
    }
    /** Enable/disable overriding certificate errors. If enabled, all certificate error events need to be handled by the DevTools client and should be answered with handleCertificateError commands. */
    setOverrideCertificateErrors(params) {
        return this._client.send("Security.setOverrideCertificateErrors", params);
    }
    /** The security state of the page changed. */
    get securityStateChanged() {
        return this._securityStateChanged;
    }
    set securityStateChanged(handler) {
        if (this._securityStateChanged) {
            this._client.removeListener("Security.securityStateChanged", this._securityStateChanged);
        }
        this._securityStateChanged = handler;
        if (handler) {
            this._client.on("Security.securityStateChanged", handler);
        }
    }
    /** There is a certificate error. If overriding certificate errors is enabled, then it should be handled with the handleCertificateError command. Note: this event does not fire if the certificate error has been allowed internally. */
    get certificateError() {
        return this._certificateError;
    }
    set certificateError(handler) {
        if (this._certificateError) {
            this._client.removeListener("Security.certificateError", this._certificateError);
        }
        this._certificateError = handler;
        if (handler) {
            this._client.on("Security.certificateError", handler);
        }
    }
}
exports.Security = Security;
/** Audits domain allows investigation of page violations and possible improvements. */
class Audits {
    constructor(client) {
        this._client = client;
    }
    /** Returns the response body and size if it were re-encoded with the specified settings. Only applies to images. */
    getEncodedResponse(params) {
        return this._client.send("Audits.getEncodedResponse", params);
    }
}
exports.Audits = Audits;
/** Network domain allows tracking network activities of the page. It exposes information about http, file, data and other requests and responses, their headers, bodies, timing, etc. */
class Network {
    constructor(client) {
        this._resourceChangedPriority = null;
        this._requestWillBeSent = null;
        this._requestServedFromCache = null;
        this._responseReceived = null;
        this._dataReceived = null;
        this._loadingFinished = null;
        this._loadingFailed = null;
        this._webSocketWillSendHandshakeRequest = null;
        this._webSocketHandshakeResponseReceived = null;
        this._webSocketCreated = null;
        this._webSocketClosed = null;
        this._webSocketFrameReceived = null;
        this._webSocketFrameError = null;
        this._webSocketFrameSent = null;
        this._eventSourceMessageReceived = null;
        this._requestIntercepted = null;
        this._client = client;
    }
    /** Enables network tracking, network events will now be delivered to the client. */
    enable(params) {
        return this._client.send("Network.enable", params);
    }
    /** Disables network tracking, prevents network events from being sent to the client. */
    disable() {
        return this._client.send("Network.disable");
    }
    /** Allows overriding user agent with the given string. */
    setUserAgentOverride(params) {
        return this._client.send("Network.setUserAgentOverride", params);
    }
    /** Specifies whether to always send extra HTTP headers with the requests from this page. */
    setExtraHTTPHeaders(params) {
        return this._client.send("Network.setExtraHTTPHeaders", params);
    }
    /** Returns content served for the given request. */
    getResponseBody(params) {
        return this._client.send("Network.getResponseBody", params);
    }
    /** Blocks URLs from loading. */
    setBlockedURLs(params) {
        return this._client.send("Network.setBlockedURLs", params);
    }
    /** This method sends a new XMLHttpRequest which is identical to the original one. The following parameters should be identical: method, url, async, request body, extra headers, withCredentials attribute, user, password. */
    replayXHR(params) {
        return this._client.send("Network.replayXHR", params);
    }
    /** Tells whether clearing browser cache is supported. */
    canClearBrowserCache() {
        return this._client.send("Network.canClearBrowserCache");
    }
    /** Clears browser cache. */
    clearBrowserCache() {
        return this._client.send("Network.clearBrowserCache");
    }
    /** Tells whether clearing browser cookies is supported. */
    canClearBrowserCookies() {
        return this._client.send("Network.canClearBrowserCookies");
    }
    /** Clears browser cookies. */
    clearBrowserCookies() {
        return this._client.send("Network.clearBrowserCookies");
    }
    /** Returns all browser cookies for the current URL. Depending on the backend support, will return detailed cookie information in the <code>cookies</code> field. */
    getCookies(params) {
        return this._client.send("Network.getCookies", params);
    }
    /** Returns all browser cookies. Depending on the backend support, will return detailed cookie information in the <code>cookies</code> field. */
    getAllCookies() {
        return this._client.send("Network.getAllCookies");
    }
    /** Deletes browser cookies with matching name and url or domain/path pair. */
    deleteCookies(params) {
        return this._client.send("Network.deleteCookies", params);
    }
    /** Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist. */
    setCookie(params) {
        return this._client.send("Network.setCookie", params);
    }
    /** Sets given cookies. */
    setCookies(params) {
        return this._client.send("Network.setCookies", params);
    }
    /** Tells whether emulation of network conditions is supported. */
    canEmulateNetworkConditions() {
        return this._client.send("Network.canEmulateNetworkConditions");
    }
    /** Activates emulation of network conditions. */
    emulateNetworkConditions(params) {
        return this._client.send("Network.emulateNetworkConditions", params);
    }
    /** Toggles ignoring cache for each request. If <code>true</code>, cache will not be used. */
    setCacheDisabled(params) {
        return this._client.send("Network.setCacheDisabled", params);
    }
    /** Toggles ignoring of service worker for each request. */
    setBypassServiceWorker(params) {
        return this._client.send("Network.setBypassServiceWorker", params);
    }
    /** For testing. */
    setDataSizeLimitsForTest(params) {
        return this._client.send("Network.setDataSizeLimitsForTest", params);
    }
    /** Returns the DER-encoded certificate. */
    getCertificate(params) {
        return this._client.send("Network.getCertificate", params);
    }
    /** Sets the requests to intercept that match a the provided patterns and optionally resource types. */
    setRequestInterception(params) {
        return this._client.send("Network.setRequestInterception", params);
    }
    /** Response to Network.requestIntercepted which either modifies the request to continue with any modifications, or blocks it, or completes it with the provided response bytes. If a network fetch occurs as a result which encounters a redirect an additional Network.requestIntercepted event will be sent with the same InterceptionId. */
    continueInterceptedRequest(params) {
        return this._client.send("Network.continueInterceptedRequest", params);
    }
    /** Returns content served for the given currently intercepted request. */
    getResponseBodyForInterception(params) {
        return this._client.send("Network.getResponseBodyForInterception", params);
    }
    /** Fired when resource loading priority is changed */
    get resourceChangedPriority() {
        return this._resourceChangedPriority;
    }
    set resourceChangedPriority(handler) {
        if (this._resourceChangedPriority) {
            this._client.removeListener("Network.resourceChangedPriority", this._resourceChangedPriority);
        }
        this._resourceChangedPriority = handler;
        if (handler) {
            this._client.on("Network.resourceChangedPriority", handler);
        }
    }
    /** Fired when page is about to send HTTP request. */
    get requestWillBeSent() {
        return this._requestWillBeSent;
    }
    set requestWillBeSent(handler) {
        if (this._requestWillBeSent) {
            this._client.removeListener("Network.requestWillBeSent", this._requestWillBeSent);
        }
        this._requestWillBeSent = handler;
        if (handler) {
            this._client.on("Network.requestWillBeSent", handler);
        }
    }
    /** Fired if request ended up loading from cache. */
    get requestServedFromCache() {
        return this._requestServedFromCache;
    }
    set requestServedFromCache(handler) {
        if (this._requestServedFromCache) {
            this._client.removeListener("Network.requestServedFromCache", this._requestServedFromCache);
        }
        this._requestServedFromCache = handler;
        if (handler) {
            this._client.on("Network.requestServedFromCache", handler);
        }
    }
    /** Fired when HTTP response is available. */
    get responseReceived() {
        return this._responseReceived;
    }
    set responseReceived(handler) {
        if (this._responseReceived) {
            this._client.removeListener("Network.responseReceived", this._responseReceived);
        }
        this._responseReceived = handler;
        if (handler) {
            this._client.on("Network.responseReceived", handler);
        }
    }
    /** Fired when data chunk was received over the network. */
    get dataReceived() {
        return this._dataReceived;
    }
    set dataReceived(handler) {
        if (this._dataReceived) {
            this._client.removeListener("Network.dataReceived", this._dataReceived);
        }
        this._dataReceived = handler;
        if (handler) {
            this._client.on("Network.dataReceived", handler);
        }
    }
    /** Fired when HTTP request has finished loading. */
    get loadingFinished() {
        return this._loadingFinished;
    }
    set loadingFinished(handler) {
        if (this._loadingFinished) {
            this._client.removeListener("Network.loadingFinished", this._loadingFinished);
        }
        this._loadingFinished = handler;
        if (handler) {
            this._client.on("Network.loadingFinished", handler);
        }
    }
    /** Fired when HTTP request has failed to load. */
    get loadingFailed() {
        return this._loadingFailed;
    }
    set loadingFailed(handler) {
        if (this._loadingFailed) {
            this._client.removeListener("Network.loadingFailed", this._loadingFailed);
        }
        this._loadingFailed = handler;
        if (handler) {
            this._client.on("Network.loadingFailed", handler);
        }
    }
    /** Fired when WebSocket is about to initiate handshake. */
    get webSocketWillSendHandshakeRequest() {
        return this._webSocketWillSendHandshakeRequest;
    }
    set webSocketWillSendHandshakeRequest(handler) {
        if (this._webSocketWillSendHandshakeRequest) {
            this._client.removeListener("Network.webSocketWillSendHandshakeRequest", this._webSocketWillSendHandshakeRequest);
        }
        this._webSocketWillSendHandshakeRequest = handler;
        if (handler) {
            this._client.on("Network.webSocketWillSendHandshakeRequest", handler);
        }
    }
    /** Fired when WebSocket handshake response becomes available. */
    get webSocketHandshakeResponseReceived() {
        return this._webSocketHandshakeResponseReceived;
    }
    set webSocketHandshakeResponseReceived(handler) {
        if (this._webSocketHandshakeResponseReceived) {
            this._client.removeListener("Network.webSocketHandshakeResponseReceived", this._webSocketHandshakeResponseReceived);
        }
        this._webSocketHandshakeResponseReceived = handler;
        if (handler) {
            this._client.on("Network.webSocketHandshakeResponseReceived", handler);
        }
    }
    /** Fired upon WebSocket creation. */
    get webSocketCreated() {
        return this._webSocketCreated;
    }
    set webSocketCreated(handler) {
        if (this._webSocketCreated) {
            this._client.removeListener("Network.webSocketCreated", this._webSocketCreated);
        }
        this._webSocketCreated = handler;
        if (handler) {
            this._client.on("Network.webSocketCreated", handler);
        }
    }
    /** Fired when WebSocket is closed. */
    get webSocketClosed() {
        return this._webSocketClosed;
    }
    set webSocketClosed(handler) {
        if (this._webSocketClosed) {
            this._client.removeListener("Network.webSocketClosed", this._webSocketClosed);
        }
        this._webSocketClosed = handler;
        if (handler) {
            this._client.on("Network.webSocketClosed", handler);
        }
    }
    /** Fired when WebSocket frame is received. */
    get webSocketFrameReceived() {
        return this._webSocketFrameReceived;
    }
    set webSocketFrameReceived(handler) {
        if (this._webSocketFrameReceived) {
            this._client.removeListener("Network.webSocketFrameReceived", this._webSocketFrameReceived);
        }
        this._webSocketFrameReceived = handler;
        if (handler) {
            this._client.on("Network.webSocketFrameReceived", handler);
        }
    }
    /** Fired when WebSocket frame error occurs. */
    get webSocketFrameError() {
        return this._webSocketFrameError;
    }
    set webSocketFrameError(handler) {
        if (this._webSocketFrameError) {
            this._client.removeListener("Network.webSocketFrameError", this._webSocketFrameError);
        }
        this._webSocketFrameError = handler;
        if (handler) {
            this._client.on("Network.webSocketFrameError", handler);
        }
    }
    /** Fired when WebSocket frame is sent. */
    get webSocketFrameSent() {
        return this._webSocketFrameSent;
    }
    set webSocketFrameSent(handler) {
        if (this._webSocketFrameSent) {
            this._client.removeListener("Network.webSocketFrameSent", this._webSocketFrameSent);
        }
        this._webSocketFrameSent = handler;
        if (handler) {
            this._client.on("Network.webSocketFrameSent", handler);
        }
    }
    /** Fired when EventSource message is received. */
    get eventSourceMessageReceived() {
        return this._eventSourceMessageReceived;
    }
    set eventSourceMessageReceived(handler) {
        if (this._eventSourceMessageReceived) {
            this._client.removeListener("Network.eventSourceMessageReceived", this._eventSourceMessageReceived);
        }
        this._eventSourceMessageReceived = handler;
        if (handler) {
            this._client.on("Network.eventSourceMessageReceived", handler);
        }
    }
    /** Details of an intercepted HTTP request, which must be either allowed, blocked, modified or mocked. */
    get requestIntercepted() {
        return this._requestIntercepted;
    }
    set requestIntercepted(handler) {
        if (this._requestIntercepted) {
            this._client.removeListener("Network.requestIntercepted", this._requestIntercepted);
        }
        this._requestIntercepted = handler;
        if (handler) {
            this._client.on("Network.requestIntercepted", handler);
        }
    }
}
exports.Network = Network;
class Database {
    constructor(client) {
        this._addDatabase = null;
        this._client = client;
    }
    /** Enables database tracking, database events will now be delivered to the client. */
    enable() {
        return this._client.send("Database.enable");
    }
    /** Disables database tracking, prevents database events from being sent to the client. */
    disable() {
        return this._client.send("Database.disable");
    }
    getDatabaseTableNames(params) {
        return this._client.send("Database.getDatabaseTableNames", params);
    }
    executeSQL(params) {
        return this._client.send("Database.executeSQL", params);
    }
    get addDatabase() {
        return this._addDatabase;
    }
    set addDatabase(handler) {
        if (this._addDatabase) {
            this._client.removeListener("Database.addDatabase", this._addDatabase);
        }
        this._addDatabase = handler;
        if (handler) {
            this._client.on("Database.addDatabase", handler);
        }
    }
}
exports.Database = Database;
class IndexedDB {
    constructor(client) {
        this._client = client;
    }
    /** Enables events from backend. */
    enable() {
        return this._client.send("IndexedDB.enable");
    }
    /** Disables events from backend. */
    disable() {
        return this._client.send("IndexedDB.disable");
    }
    /** Requests database names for given security origin. */
    requestDatabaseNames(params) {
        return this._client.send("IndexedDB.requestDatabaseNames", params);
    }
    /** Requests database with given name in given frame. */
    requestDatabase(params) {
        return this._client.send("IndexedDB.requestDatabase", params);
    }
    /** Requests data from object store or index. */
    requestData(params) {
        return this._client.send("IndexedDB.requestData", params);
    }
    /** Clears all entries from an object store. */
    clearObjectStore(params) {
        return this._client.send("IndexedDB.clearObjectStore", params);
    }
    /** Deletes a database. */
    deleteDatabase(params) {
        return this._client.send("IndexedDB.deleteDatabase", params);
    }
}
exports.IndexedDB = IndexedDB;
class CacheStorage {
    constructor(client) {
        this._client = client;
    }
    /** Requests cache names. */
    requestCacheNames(params) {
        return this._client.send("CacheStorage.requestCacheNames", params);
    }
    /** Requests data from cache. */
    requestEntries(params) {
        return this._client.send("CacheStorage.requestEntries", params);
    }
    /** Deletes a cache. */
    deleteCache(params) {
        return this._client.send("CacheStorage.deleteCache", params);
    }
    /** Deletes a cache entry. */
    deleteEntry(params) {
        return this._client.send("CacheStorage.deleteEntry", params);
    }
    /** Fetches cache entry. */
    requestCachedResponse(params) {
        return this._client.send("CacheStorage.requestCachedResponse", params);
    }
}
exports.CacheStorage = CacheStorage;
/** Query and modify DOM storage. */
class DOMStorage {
    constructor(client) {
        this._domStorageItemsCleared = null;
        this._domStorageItemRemoved = null;
        this._domStorageItemAdded = null;
        this._domStorageItemUpdated = null;
        this._client = client;
    }
    /** Enables storage tracking, storage events will now be delivered to the client. */
    enable() {
        return this._client.send("DOMStorage.enable");
    }
    /** Disables storage tracking, prevents storage events from being sent to the client. */
    disable() {
        return this._client.send("DOMStorage.disable");
    }
    clear(params) {
        return this._client.send("DOMStorage.clear", params);
    }
    getDOMStorageItems(params) {
        return this._client.send("DOMStorage.getDOMStorageItems", params);
    }
    setDOMStorageItem(params) {
        return this._client.send("DOMStorage.setDOMStorageItem", params);
    }
    removeDOMStorageItem(params) {
        return this._client.send("DOMStorage.removeDOMStorageItem", params);
    }
    get domStorageItemsCleared() {
        return this._domStorageItemsCleared;
    }
    set domStorageItemsCleared(handler) {
        if (this._domStorageItemsCleared) {
            this._client.removeListener("DOMStorage.domStorageItemsCleared", this._domStorageItemsCleared);
        }
        this._domStorageItemsCleared = handler;
        if (handler) {
            this._client.on("DOMStorage.domStorageItemsCleared", handler);
        }
    }
    get domStorageItemRemoved() {
        return this._domStorageItemRemoved;
    }
    set domStorageItemRemoved(handler) {
        if (this._domStorageItemRemoved) {
            this._client.removeListener("DOMStorage.domStorageItemRemoved", this._domStorageItemRemoved);
        }
        this._domStorageItemRemoved = handler;
        if (handler) {
            this._client.on("DOMStorage.domStorageItemRemoved", handler);
        }
    }
    get domStorageItemAdded() {
        return this._domStorageItemAdded;
    }
    set domStorageItemAdded(handler) {
        if (this._domStorageItemAdded) {
            this._client.removeListener("DOMStorage.domStorageItemAdded", this._domStorageItemAdded);
        }
        this._domStorageItemAdded = handler;
        if (handler) {
            this._client.on("DOMStorage.domStorageItemAdded", handler);
        }
    }
    get domStorageItemUpdated() {
        return this._domStorageItemUpdated;
    }
    set domStorageItemUpdated(handler) {
        if (this._domStorageItemUpdated) {
            this._client.removeListener("DOMStorage.domStorageItemUpdated", this._domStorageItemUpdated);
        }
        this._domStorageItemUpdated = handler;
        if (handler) {
            this._client.on("DOMStorage.domStorageItemUpdated", handler);
        }
    }
}
exports.DOMStorage = DOMStorage;
class ApplicationCache {
    constructor(client) {
        this._applicationCacheStatusUpdated = null;
        this._networkStateUpdated = null;
        this._client = client;
    }
    /** Returns array of frame identifiers with manifest urls for each frame containing a document associated with some application cache. */
    getFramesWithManifests() {
        return this._client.send("ApplicationCache.getFramesWithManifests");
    }
    /** Enables application cache domain notifications. */
    enable() {
        return this._client.send("ApplicationCache.enable");
    }
    /** Returns manifest URL for document in the given frame. */
    getManifestForFrame(params) {
        return this._client.send("ApplicationCache.getManifestForFrame", params);
    }
    /** Returns relevant application cache data for the document in given frame. */
    getApplicationCacheForFrame(params) {
        return this._client.send("ApplicationCache.getApplicationCacheForFrame", params);
    }
    get applicationCacheStatusUpdated() {
        return this._applicationCacheStatusUpdated;
    }
    set applicationCacheStatusUpdated(handler) {
        if (this._applicationCacheStatusUpdated) {
            this._client.removeListener("ApplicationCache.applicationCacheStatusUpdated", this._applicationCacheStatusUpdated);
        }
        this._applicationCacheStatusUpdated = handler;
        if (handler) {
            this._client.on("ApplicationCache.applicationCacheStatusUpdated", handler);
        }
    }
    get networkStateUpdated() {
        return this._networkStateUpdated;
    }
    set networkStateUpdated(handler) {
        if (this._networkStateUpdated) {
            this._client.removeListener("ApplicationCache.networkStateUpdated", this._networkStateUpdated);
        }
        this._networkStateUpdated = handler;
        if (handler) {
            this._client.on("ApplicationCache.networkStateUpdated", handler);
        }
    }
}
exports.ApplicationCache = ApplicationCache;
/** This domain exposes DOM read/write operations. Each DOM Node is represented with its mirror object that has an <code>id</code>. This <code>id</code> can be used to get additional information on the Node, resolve it into the JavaScript object wrapper, etc. It is important that client receives DOM events only for the nodes that are known to the client. Backend keeps track of the nodes that were sent to the client and never sends the same node twice. It is client's responsibility to collect information about the nodes that were sent to the client.<p>Note that <code>iframe</code> owner elements will return corresponding document elements as their child nodes.</p> */
class DOM {
    constructor(client) {
        this._documentUpdated = null;
        this._setChildNodes = null;
        this._attributeModified = null;
        this._attributeRemoved = null;
        this._inlineStyleInvalidated = null;
        this._characterDataModified = null;
        this._childNodeCountUpdated = null;
        this._childNodeInserted = null;
        this._childNodeRemoved = null;
        this._shadowRootPushed = null;
        this._shadowRootPopped = null;
        this._pseudoElementAdded = null;
        this._pseudoElementRemoved = null;
        this._distributedNodesUpdated = null;
        this._client = client;
    }
    /** Enables DOM agent for the given page. */
    enable() {
        return this._client.send("DOM.enable");
    }
    /** Disables DOM agent for the given page. */
    disable() {
        return this._client.send("DOM.disable");
    }
    /** Returns the root DOM node (and optionally the subtree) to the caller. */
    getDocument(params) {
        return this._client.send("DOM.getDocument", params);
    }
    /** Returns the root DOM node (and optionally the subtree) to the caller. */
    getFlattenedDocument(params) {
        return this._client.send("DOM.getFlattenedDocument", params);
    }
    /** Collects class names for the node with given id and all of it's child nodes. */
    collectClassNamesFromSubtree(params) {
        return this._client.send("DOM.collectClassNamesFromSubtree", params);
    }
    /** Requests that children of the node with given id are returned to the caller in form of <code>setChildNodes</code> events where not only immediate children are retrieved, but all children down to the specified depth. */
    requestChildNodes(params) {
        return this._client.send("DOM.requestChildNodes", params);
    }
    /** Executes <code>querySelector</code> on a given node. */
    querySelector(params) {
        return this._client.send("DOM.querySelector", params);
    }
    /** Executes <code>querySelectorAll</code> on a given node. */
    querySelectorAll(params) {
        return this._client.send("DOM.querySelectorAll", params);
    }
    /** Sets node name for a node with given id. */
    setNodeName(params) {
        return this._client.send("DOM.setNodeName", params);
    }
    /** Sets node value for a node with given id. */
    setNodeValue(params) {
        return this._client.send("DOM.setNodeValue", params);
    }
    /** Removes node with given id. */
    removeNode(params) {
        return this._client.send("DOM.removeNode", params);
    }
    /** Sets attribute for an element with given id. */
    setAttributeValue(params) {
        return this._client.send("DOM.setAttributeValue", params);
    }
    /** Sets attributes on element with given id. This method is useful when user edits some existing attribute value and types in several attribute name/value pairs. */
    setAttributesAsText(params) {
        return this._client.send("DOM.setAttributesAsText", params);
    }
    /** Removes attribute with given name from an element with given id. */
    removeAttribute(params) {
        return this._client.send("DOM.removeAttribute", params);
    }
    /** Returns node's HTML markup. */
    getOuterHTML(params) {
        return this._client.send("DOM.getOuterHTML", params);
    }
    /** Sets node HTML markup, returns new node id. */
    setOuterHTML(params) {
        return this._client.send("DOM.setOuterHTML", params);
    }
    /** Searches for a given string in the DOM tree. Use <code>getSearchResults</code> to access search results or <code>cancelSearch</code> to end this search session. */
    performSearch(params) {
        return this._client.send("DOM.performSearch", params);
    }
    /** Returns search results from given <code>fromIndex</code> to given <code>toIndex</code> from the search with the given identifier. */
    getSearchResults(params) {
        return this._client.send("DOM.getSearchResults", params);
    }
    /** Discards search results from the session with the given id. <code>getSearchResults</code> should no longer be called for that search. */
    discardSearchResults(params) {
        return this._client.send("DOM.discardSearchResults", params);
    }
    /** Requests that the node is sent to the caller given the JavaScript node object reference. All nodes that form the path from the node to the root are also sent to the client as a series of <code>setChildNodes</code> notifications. */
    requestNode(params) {
        return this._client.send("DOM.requestNode", params);
    }
    /** Highlights given rectangle. */
    highlightRect() {
        return this._client.send("DOM.highlightRect");
    }
    /** Highlights DOM node. */
    highlightNode() {
        return this._client.send("DOM.highlightNode");
    }
    /** Hides any highlight. */
    hideHighlight() {
        return this._client.send("DOM.hideHighlight");
    }
    /** Requests that the node is sent to the caller given its path. // FIXME, use XPath */
    pushNodeByPathToFrontend(params) {
        return this._client.send("DOM.pushNodeByPathToFrontend", params);
    }
    /** Requests that a batch of nodes is sent to the caller given their backend node ids. */
    pushNodesByBackendIdsToFrontend(params) {
        return this._client.send("DOM.pushNodesByBackendIdsToFrontend", params);
    }
    /** Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions). */
    setInspectedNode(params) {
        return this._client.send("DOM.setInspectedNode", params);
    }
    /** Resolves the JavaScript node object for a given NodeId or BackendNodeId. */
    resolveNode(params) {
        return this._client.send("DOM.resolveNode", params);
    }
    /** Returns attributes for the specified node. */
    getAttributes(params) {
        return this._client.send("DOM.getAttributes", params);
    }
    /** Creates a deep copy of the specified node and places it into the target container before the given anchor. */
    copyTo(params) {
        return this._client.send("DOM.copyTo", params);
    }
    /** Moves node into the new container, places it before the given anchor. */
    moveTo(params) {
        return this._client.send("DOM.moveTo", params);
    }
    /** Undoes the last performed action. */
    undo() {
        return this._client.send("DOM.undo");
    }
    /** Re-does the last undone action. */
    redo() {
        return this._client.send("DOM.redo");
    }
    /** Marks last undoable state. */
    markUndoableState() {
        return this._client.send("DOM.markUndoableState");
    }
    /** Focuses the given element. */
    focus(params) {
        return this._client.send("DOM.focus", params);
    }
    /** Sets files for the given file input element. */
    setFileInputFiles(params) {
        return this._client.send("DOM.setFileInputFiles", params);
    }
    /** Returns boxes for the given node. */
    getBoxModel(params) {
        return this._client.send("DOM.getBoxModel", params);
    }
    /** Returns node id at given location. */
    getNodeForLocation(params) {
        return this._client.send("DOM.getNodeForLocation", params);
    }
    /** Returns the id of the nearest ancestor that is a relayout boundary. */
    getRelayoutBoundary(params) {
        return this._client.send("DOM.getRelayoutBoundary", params);
    }
    /** Describes node given its id, does not require domain to be enabled. Does not start tracking any objects, can be used for automation. */
    describeNode(params) {
        return this._client.send("DOM.describeNode", params);
    }
    /** Fired when <code>Document</code> has been totally updated. Node ids are no longer valid. */
    get documentUpdated() {
        return this._documentUpdated;
    }
    set documentUpdated(handler) {
        if (this._documentUpdated) {
            this._client.removeListener("DOM.documentUpdated", this._documentUpdated);
        }
        this._documentUpdated = handler;
        if (handler) {
            this._client.on("DOM.documentUpdated", handler);
        }
    }
    /** Fired when backend wants to provide client with the missing DOM structure. This happens upon most of the calls requesting node ids. */
    get setChildNodes() {
        return this._setChildNodes;
    }
    set setChildNodes(handler) {
        if (this._setChildNodes) {
            this._client.removeListener("DOM.setChildNodes", this._setChildNodes);
        }
        this._setChildNodes = handler;
        if (handler) {
            this._client.on("DOM.setChildNodes", handler);
        }
    }
    /** Fired when <code>Element</code>'s attribute is modified. */
    get attributeModified() {
        return this._attributeModified;
    }
    set attributeModified(handler) {
        if (this._attributeModified) {
            this._client.removeListener("DOM.attributeModified", this._attributeModified);
        }
        this._attributeModified = handler;
        if (handler) {
            this._client.on("DOM.attributeModified", handler);
        }
    }
    /** Fired when <code>Element</code>'s attribute is removed. */
    get attributeRemoved() {
        return this._attributeRemoved;
    }
    set attributeRemoved(handler) {
        if (this._attributeRemoved) {
            this._client.removeListener("DOM.attributeRemoved", this._attributeRemoved);
        }
        this._attributeRemoved = handler;
        if (handler) {
            this._client.on("DOM.attributeRemoved", handler);
        }
    }
    /** Fired when <code>Element</code>'s inline style is modified via a CSS property modification. */
    get inlineStyleInvalidated() {
        return this._inlineStyleInvalidated;
    }
    set inlineStyleInvalidated(handler) {
        if (this._inlineStyleInvalidated) {
            this._client.removeListener("DOM.inlineStyleInvalidated", this._inlineStyleInvalidated);
        }
        this._inlineStyleInvalidated = handler;
        if (handler) {
            this._client.on("DOM.inlineStyleInvalidated", handler);
        }
    }
    /** Mirrors <code>DOMCharacterDataModified</code> event. */
    get characterDataModified() {
        return this._characterDataModified;
    }
    set characterDataModified(handler) {
        if (this._characterDataModified) {
            this._client.removeListener("DOM.characterDataModified", this._characterDataModified);
        }
        this._characterDataModified = handler;
        if (handler) {
            this._client.on("DOM.characterDataModified", handler);
        }
    }
    /** Fired when <code>Container</code>'s child node count has changed. */
    get childNodeCountUpdated() {
        return this._childNodeCountUpdated;
    }
    set childNodeCountUpdated(handler) {
        if (this._childNodeCountUpdated) {
            this._client.removeListener("DOM.childNodeCountUpdated", this._childNodeCountUpdated);
        }
        this._childNodeCountUpdated = handler;
        if (handler) {
            this._client.on("DOM.childNodeCountUpdated", handler);
        }
    }
    /** Mirrors <code>DOMNodeInserted</code> event. */
    get childNodeInserted() {
        return this._childNodeInserted;
    }
    set childNodeInserted(handler) {
        if (this._childNodeInserted) {
            this._client.removeListener("DOM.childNodeInserted", this._childNodeInserted);
        }
        this._childNodeInserted = handler;
        if (handler) {
            this._client.on("DOM.childNodeInserted", handler);
        }
    }
    /** Mirrors <code>DOMNodeRemoved</code> event. */
    get childNodeRemoved() {
        return this._childNodeRemoved;
    }
    set childNodeRemoved(handler) {
        if (this._childNodeRemoved) {
            this._client.removeListener("DOM.childNodeRemoved", this._childNodeRemoved);
        }
        this._childNodeRemoved = handler;
        if (handler) {
            this._client.on("DOM.childNodeRemoved", handler);
        }
    }
    /** Called when shadow root is pushed into the element. */
    get shadowRootPushed() {
        return this._shadowRootPushed;
    }
    set shadowRootPushed(handler) {
        if (this._shadowRootPushed) {
            this._client.removeListener("DOM.shadowRootPushed", this._shadowRootPushed);
        }
        this._shadowRootPushed = handler;
        if (handler) {
            this._client.on("DOM.shadowRootPushed", handler);
        }
    }
    /** Called when shadow root is popped from the element. */
    get shadowRootPopped() {
        return this._shadowRootPopped;
    }
    set shadowRootPopped(handler) {
        if (this._shadowRootPopped) {
            this._client.removeListener("DOM.shadowRootPopped", this._shadowRootPopped);
        }
        this._shadowRootPopped = handler;
        if (handler) {
            this._client.on("DOM.shadowRootPopped", handler);
        }
    }
    /** Called when a pseudo element is added to an element. */
    get pseudoElementAdded() {
        return this._pseudoElementAdded;
    }
    set pseudoElementAdded(handler) {
        if (this._pseudoElementAdded) {
            this._client.removeListener("DOM.pseudoElementAdded", this._pseudoElementAdded);
        }
        this._pseudoElementAdded = handler;
        if (handler) {
            this._client.on("DOM.pseudoElementAdded", handler);
        }
    }
    /** Called when a pseudo element is removed from an element. */
    get pseudoElementRemoved() {
        return this._pseudoElementRemoved;
    }
    set pseudoElementRemoved(handler) {
        if (this._pseudoElementRemoved) {
            this._client.removeListener("DOM.pseudoElementRemoved", this._pseudoElementRemoved);
        }
        this._pseudoElementRemoved = handler;
        if (handler) {
            this._client.on("DOM.pseudoElementRemoved", handler);
        }
    }
    /** Called when distrubution is changed. */
    get distributedNodesUpdated() {
        return this._distributedNodesUpdated;
    }
    set distributedNodesUpdated(handler) {
        if (this._distributedNodesUpdated) {
            this._client.removeListener("DOM.distributedNodesUpdated", this._distributedNodesUpdated);
        }
        this._distributedNodesUpdated = handler;
        if (handler) {
            this._client.on("DOM.distributedNodesUpdated", handler);
        }
    }
}
exports.DOM = DOM;
/** This domain exposes CSS read/write operations. All CSS objects (stylesheets, rules, and styles) have an associated <code>id</code> used in subsequent operations on the related object. Each object type has a specific <code>id</code> structure, and those are not interchangeable between objects of different kinds. CSS objects can be loaded using the <code>get*ForNode()</code> calls (which accept a DOM node id). A client can also keep track of stylesheets via the <code>styleSheetAdded</code>/<code>styleSheetRemoved</code> events and subsequently load the required stylesheet contents using the <code>getStyleSheet[Text]()</code> methods. */
class CSS {
    constructor(client) {
        this._mediaQueryResultChanged = null;
        this._fontsUpdated = null;
        this._styleSheetChanged = null;
        this._styleSheetAdded = null;
        this._styleSheetRemoved = null;
        this._client = client;
    }
    /** Enables the CSS agent for the given page. Clients should not assume that the CSS agent has been enabled until the result of this command is received. */
    enable() {
        return this._client.send("CSS.enable");
    }
    /** Disables the CSS agent for the given page. */
    disable() {
        return this._client.send("CSS.disable");
    }
    /** Returns requested styles for a DOM node identified by <code>nodeId</code>. */
    getMatchedStylesForNode(params) {
        return this._client.send("CSS.getMatchedStylesForNode", params);
    }
    /** Returns the styles defined inline (explicitly in the "style" attribute and implicitly, using DOM attributes) for a DOM node identified by <code>nodeId</code>. */
    getInlineStylesForNode(params) {
        return this._client.send("CSS.getInlineStylesForNode", params);
    }
    /** Returns the computed style for a DOM node identified by <code>nodeId</code>. */
    getComputedStyleForNode(params) {
        return this._client.send("CSS.getComputedStyleForNode", params);
    }
    /** Requests information about platform fonts which we used to render child TextNodes in the given node. */
    getPlatformFontsForNode(params) {
        return this._client.send("CSS.getPlatformFontsForNode", params);
    }
    /** Returns the current textual content and the URL for a stylesheet. */
    getStyleSheetText(params) {
        return this._client.send("CSS.getStyleSheetText", params);
    }
    /** Returns all class names from specified stylesheet. */
    collectClassNames(params) {
        return this._client.send("CSS.collectClassNames", params);
    }
    /** Sets the new stylesheet text. */
    setStyleSheetText(params) {
        return this._client.send("CSS.setStyleSheetText", params);
    }
    /** Modifies the rule selector. */
    setRuleSelector(params) {
        return this._client.send("CSS.setRuleSelector", params);
    }
    /** Modifies the keyframe rule key text. */
    setKeyframeKey(params) {
        return this._client.send("CSS.setKeyframeKey", params);
    }
    /** Applies specified style edits one after another in the given order. */
    setStyleTexts(params) {
        return this._client.send("CSS.setStyleTexts", params);
    }
    /** Modifies the rule selector. */
    setMediaText(params) {
        return this._client.send("CSS.setMediaText", params);
    }
    /** Creates a new special "via-inspector" stylesheet in the frame with given <code>frameId</code>. */
    createStyleSheet(params) {
        return this._client.send("CSS.createStyleSheet", params);
    }
    /** Inserts a new rule with the given <code>ruleText</code> in a stylesheet with given <code>styleSheetId</code>, at the position specified by <code>location</code>. */
    addRule(params) {
        return this._client.send("CSS.addRule", params);
    }
    /** Ensures that the given node will have specified pseudo-classes whenever its style is computed by the browser. */
    forcePseudoState(params) {
        return this._client.send("CSS.forcePseudoState", params);
    }
    /** Returns all media queries parsed by the rendering engine. */
    getMediaQueries() {
        return this._client.send("CSS.getMediaQueries");
    }
    /** Find a rule with the given active property for the given node and set the new value for this property */
    setEffectivePropertyValueForNode(params) {
        return this._client.send("CSS.setEffectivePropertyValueForNode", params);
    }
    getBackgroundColors(params) {
        return this._client.send("CSS.getBackgroundColors", params);
    }
    /** Enables the selector recording. */
    startRuleUsageTracking() {
        return this._client.send("CSS.startRuleUsageTracking");
    }
    /** Obtain list of rules that became used since last call to this method (or since start of coverage instrumentation) */
    takeCoverageDelta() {
        return this._client.send("CSS.takeCoverageDelta");
    }
    /** The list of rules with an indication of whether these were used */
    stopRuleUsageTracking() {
        return this._client.send("CSS.stopRuleUsageTracking");
    }
    /** Fires whenever a MediaQuery result changes (for example, after a browser window has been resized.) The current implementation considers only viewport-dependent media features. */
    get mediaQueryResultChanged() {
        return this._mediaQueryResultChanged;
    }
    set mediaQueryResultChanged(handler) {
        if (this._mediaQueryResultChanged) {
            this._client.removeListener("CSS.mediaQueryResultChanged", this._mediaQueryResultChanged);
        }
        this._mediaQueryResultChanged = handler;
        if (handler) {
            this._client.on("CSS.mediaQueryResultChanged", handler);
        }
    }
    /** Fires whenever a web font gets loaded. */
    get fontsUpdated() {
        return this._fontsUpdated;
    }
    set fontsUpdated(handler) {
        if (this._fontsUpdated) {
            this._client.removeListener("CSS.fontsUpdated", this._fontsUpdated);
        }
        this._fontsUpdated = handler;
        if (handler) {
            this._client.on("CSS.fontsUpdated", handler);
        }
    }
    /** Fired whenever a stylesheet is changed as a result of the client operation. */
    get styleSheetChanged() {
        return this._styleSheetChanged;
    }
    set styleSheetChanged(handler) {
        if (this._styleSheetChanged) {
            this._client.removeListener("CSS.styleSheetChanged", this._styleSheetChanged);
        }
        this._styleSheetChanged = handler;
        if (handler) {
            this._client.on("CSS.styleSheetChanged", handler);
        }
    }
    /** Fired whenever an active document stylesheet is added. */
    get styleSheetAdded() {
        return this._styleSheetAdded;
    }
    set styleSheetAdded(handler) {
        if (this._styleSheetAdded) {
            this._client.removeListener("CSS.styleSheetAdded", this._styleSheetAdded);
        }
        this._styleSheetAdded = handler;
        if (handler) {
            this._client.on("CSS.styleSheetAdded", handler);
        }
    }
    /** Fired whenever an active document stylesheet is removed. */
    get styleSheetRemoved() {
        return this._styleSheetRemoved;
    }
    set styleSheetRemoved(handler) {
        if (this._styleSheetRemoved) {
            this._client.removeListener("CSS.styleSheetRemoved", this._styleSheetRemoved);
        }
        this._styleSheetRemoved = handler;
        if (handler) {
            this._client.on("CSS.styleSheetRemoved", handler);
        }
    }
}
exports.CSS = CSS;
/** This domain facilitates obtaining document snapshots with DOM, layout, and style information. */
class DOMSnapshot {
    constructor(client) {
        this._client = client;
    }
    /** Returns a document snapshot, including the full DOM tree of the root node (including iframes, template contents, and imported documents) in a flattened array, as well as layout and white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is flattened.  */
    getSnapshot(params) {
        return this._client.send("DOMSnapshot.getSnapshot", params);
    }
}
exports.DOMSnapshot = DOMSnapshot;
/** Input/Output operations for streams produced by DevTools. */
class IO {
    constructor(client) {
        this._client = client;
    }
    /** Read a chunk of the stream */
    read(params) {
        return this._client.send("IO.read", params);
    }
    /** Close the stream, discard any temporary backing storage. */
    close(params) {
        return this._client.send("IO.close", params);
    }
    /** Return UUID of Blob object specified by a remote object id. */
    resolveBlob(params) {
        return this._client.send("IO.resolveBlob", params);
    }
}
exports.IO = IO;
/** DOM debugging allows setting breakpoints on particular DOM operations and events. JavaScript execution will stop on these operations as if there was a regular breakpoint set. */
class DOMDebugger {
    constructor(client) {
        this._client = client;
    }
    /** Sets breakpoint on particular operation with DOM. */
    setDOMBreakpoint(params) {
        return this._client.send("DOMDebugger.setDOMBreakpoint", params);
    }
    /** Removes DOM breakpoint that was set using <code>setDOMBreakpoint</code>. */
    removeDOMBreakpoint(params) {
        return this._client.send("DOMDebugger.removeDOMBreakpoint", params);
    }
    /** Sets breakpoint on particular DOM event. */
    setEventListenerBreakpoint(params) {
        return this._client.send("DOMDebugger.setEventListenerBreakpoint", params);
    }
    /** Removes breakpoint on particular DOM event. */
    removeEventListenerBreakpoint(params) {
        return this._client.send("DOMDebugger.removeEventListenerBreakpoint", params);
    }
    /** Sets breakpoint on particular native event. */
    setInstrumentationBreakpoint(params) {
        return this._client.send("DOMDebugger.setInstrumentationBreakpoint", params);
    }
    /** Removes breakpoint on particular native event. */
    removeInstrumentationBreakpoint(params) {
        return this._client.send("DOMDebugger.removeInstrumentationBreakpoint", params);
    }
    /** Sets breakpoint on XMLHttpRequest. */
    setXHRBreakpoint(params) {
        return this._client.send("DOMDebugger.setXHRBreakpoint", params);
    }
    /** Removes breakpoint from XMLHttpRequest. */
    removeXHRBreakpoint(params) {
        return this._client.send("DOMDebugger.removeXHRBreakpoint", params);
    }
    /** Returns event listeners of the given object. */
    getEventListeners(params) {
        return this._client.send("DOMDebugger.getEventListeners", params);
    }
}
exports.DOMDebugger = DOMDebugger;
/** Supports additional targets discovery and allows to attach to them. */
class Target {
    constructor(client) {
        this._targetCreated = null;
        this._targetInfoChanged = null;
        this._targetDestroyed = null;
        this._attachedToTarget = null;
        this._detachedFromTarget = null;
        this._receivedMessageFromTarget = null;
        this._client = client;
    }
    /** Controls whether to discover available targets and notify via <code>targetCreated/targetInfoChanged/targetDestroyed</code> events. */
    setDiscoverTargets(params) {
        return this._client.send("Target.setDiscoverTargets", params);
    }
    /** Controls whether to automatically attach to new targets which are considered to be related to this one. When turned on, attaches to all existing related targets as well. When turned off, automatically detaches from all currently attached targets. */
    setAutoAttach(params) {
        return this._client.send("Target.setAutoAttach", params);
    }
    setAttachToFrames(params) {
        return this._client.send("Target.setAttachToFrames", params);
    }
    /** Enables target discovery for the specified locations, when <code>setDiscoverTargets</code> was set to <code>true</code>. */
    setRemoteLocations(params) {
        return this._client.send("Target.setRemoteLocations", params);
    }
    /** Sends protocol message over session with given id. */
    sendMessageToTarget(params) {
        return this._client.send("Target.sendMessageToTarget", params);
    }
    /** Returns information about a target. */
    getTargetInfo(params) {
        return this._client.send("Target.getTargetInfo", params);
    }
    /** Activates (focuses) the target. */
    activateTarget(params) {
        return this._client.send("Target.activateTarget", params);
    }
    /** Closes the target. If the target is a page that gets closed too. */
    closeTarget(params) {
        return this._client.send("Target.closeTarget", params);
    }
    /** Attaches to the target with given id. */
    attachToTarget(params) {
        return this._client.send("Target.attachToTarget", params);
    }
    /** Detaches session with given id. */
    detachFromTarget(params) {
        return this._client.send("Target.detachFromTarget", params);
    }
    /** Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than one. */
    createBrowserContext() {
        return this._client.send("Target.createBrowserContext");
    }
    /** Deletes a BrowserContext, will fail of any open page uses it. */
    disposeBrowserContext(params) {
        return this._client.send("Target.disposeBrowserContext", params);
    }
    /** Creates a new page. */
    createTarget(params) {
        return this._client.send("Target.createTarget", params);
    }
    /** Retrieves a list of available targets. */
    getTargets() {
        return this._client.send("Target.getTargets");
    }
    /** Issued when a possible inspection target is created. */
    get targetCreated() {
        return this._targetCreated;
    }
    set targetCreated(handler) {
        if (this._targetCreated) {
            this._client.removeListener("Target.targetCreated", this._targetCreated);
        }
        this._targetCreated = handler;
        if (handler) {
            this._client.on("Target.targetCreated", handler);
        }
    }
    /** Issued when some information about a target has changed. This only happens between <code>targetCreated</code> and <code>targetDestroyed</code>. */
    get targetInfoChanged() {
        return this._targetInfoChanged;
    }
    set targetInfoChanged(handler) {
        if (this._targetInfoChanged) {
            this._client.removeListener("Target.targetInfoChanged", this._targetInfoChanged);
        }
        this._targetInfoChanged = handler;
        if (handler) {
            this._client.on("Target.targetInfoChanged", handler);
        }
    }
    /** Issued when a target is destroyed. */
    get targetDestroyed() {
        return this._targetDestroyed;
    }
    set targetDestroyed(handler) {
        if (this._targetDestroyed) {
            this._client.removeListener("Target.targetDestroyed", this._targetDestroyed);
        }
        this._targetDestroyed = handler;
        if (handler) {
            this._client.on("Target.targetDestroyed", handler);
        }
    }
    /** Issued when attached to target because of auto-attach or <code>attachToTarget</code> command. */
    get attachedToTarget() {
        return this._attachedToTarget;
    }
    set attachedToTarget(handler) {
        if (this._attachedToTarget) {
            this._client.removeListener("Target.attachedToTarget", this._attachedToTarget);
        }
        this._attachedToTarget = handler;
        if (handler) {
            this._client.on("Target.attachedToTarget", handler);
        }
    }
    /** Issued when detached from target for any reason (including <code>detachFromTarget</code> command). Can be issued multiple times per target if multiple sessions have been attached to it. */
    get detachedFromTarget() {
        return this._detachedFromTarget;
    }
    set detachedFromTarget(handler) {
        if (this._detachedFromTarget) {
            this._client.removeListener("Target.detachedFromTarget", this._detachedFromTarget);
        }
        this._detachedFromTarget = handler;
        if (handler) {
            this._client.on("Target.detachedFromTarget", handler);
        }
    }
    /** Notifies about a new protocol message received from the session (as reported in <code>attachedToTarget</code> event). */
    get receivedMessageFromTarget() {
        return this._receivedMessageFromTarget;
    }
    set receivedMessageFromTarget(handler) {
        if (this._receivedMessageFromTarget) {
            this._client.removeListener("Target.receivedMessageFromTarget", this._receivedMessageFromTarget);
        }
        this._receivedMessageFromTarget = handler;
        if (handler) {
            this._client.on("Target.receivedMessageFromTarget", handler);
        }
    }
}
exports.Target = Target;
/** This domain provides experimental commands only supported in headless mode. */
class HeadlessExperimental {
    constructor(client) {
        this._needsBeginFramesChanged = null;
        this._mainFrameReadyForScreenshots = null;
        this._client = client;
    }
    /** Enables headless events for the target. */
    enable() {
        return this._client.send("HeadlessExperimental.enable");
    }
    /** Disables headless events for the target. */
    disable() {
        return this._client.send("HeadlessExperimental.disable");
    }
    /** Sends a BeginFrame to the target and returns when the frame was completed. Optionally captures a screenshot from the resulting frame. Requires that the target was created with enabled BeginFrameControl. */
    beginFrame(params) {
        return this._client.send("HeadlessExperimental.beginFrame", params);
    }
    /** Issued when the target starts or stops needing BeginFrames. */
    get needsBeginFramesChanged() {
        return this._needsBeginFramesChanged;
    }
    set needsBeginFramesChanged(handler) {
        if (this._needsBeginFramesChanged) {
            this._client.removeListener("HeadlessExperimental.needsBeginFramesChanged", this._needsBeginFramesChanged);
        }
        this._needsBeginFramesChanged = handler;
        if (handler) {
            this._client.on("HeadlessExperimental.needsBeginFramesChanged", handler);
        }
    }
    /** Issued when the main frame has first submitted a frame to the browser. May only be fired while a BeginFrame is in flight. Before this event, screenshotting requests may fail. */
    get mainFrameReadyForScreenshots() {
        return this._mainFrameReadyForScreenshots;
    }
    set mainFrameReadyForScreenshots(handler) {
        if (this._mainFrameReadyForScreenshots) {
            this._client.removeListener("HeadlessExperimental.mainFrameReadyForScreenshots", this._mainFrameReadyForScreenshots);
        }
        this._mainFrameReadyForScreenshots = handler;
        if (handler) {
            this._client.on("HeadlessExperimental.mainFrameReadyForScreenshots", handler);
        }
    }
}
exports.HeadlessExperimental = HeadlessExperimental;
class ServiceWorker {
    constructor(client) {
        this._workerRegistrationUpdated = null;
        this._workerVersionUpdated = null;
        this._workerErrorReported = null;
        this._client = client;
    }
    enable() {
        return this._client.send("ServiceWorker.enable");
    }
    disable() {
        return this._client.send("ServiceWorker.disable");
    }
    unregister(params) {
        return this._client.send("ServiceWorker.unregister", params);
    }
    updateRegistration(params) {
        return this._client.send("ServiceWorker.updateRegistration", params);
    }
    startWorker(params) {
        return this._client.send("ServiceWorker.startWorker", params);
    }
    skipWaiting(params) {
        return this._client.send("ServiceWorker.skipWaiting", params);
    }
    stopWorker(params) {
        return this._client.send("ServiceWorker.stopWorker", params);
    }
    stopAllWorkers() {
        return this._client.send("ServiceWorker.stopAllWorkers");
    }
    inspectWorker(params) {
        return this._client.send("ServiceWorker.inspectWorker", params);
    }
    setForceUpdateOnPageLoad(params) {
        return this._client.send("ServiceWorker.setForceUpdateOnPageLoad", params);
    }
    deliverPushMessage(params) {
        return this._client.send("ServiceWorker.deliverPushMessage", params);
    }
    dispatchSyncEvent(params) {
        return this._client.send("ServiceWorker.dispatchSyncEvent", params);
    }
    get workerRegistrationUpdated() {
        return this._workerRegistrationUpdated;
    }
    set workerRegistrationUpdated(handler) {
        if (this._workerRegistrationUpdated) {
            this._client.removeListener("ServiceWorker.workerRegistrationUpdated", this._workerRegistrationUpdated);
        }
        this._workerRegistrationUpdated = handler;
        if (handler) {
            this._client.on("ServiceWorker.workerRegistrationUpdated", handler);
        }
    }
    get workerVersionUpdated() {
        return this._workerVersionUpdated;
    }
    set workerVersionUpdated(handler) {
        if (this._workerVersionUpdated) {
            this._client.removeListener("ServiceWorker.workerVersionUpdated", this._workerVersionUpdated);
        }
        this._workerVersionUpdated = handler;
        if (handler) {
            this._client.on("ServiceWorker.workerVersionUpdated", handler);
        }
    }
    get workerErrorReported() {
        return this._workerErrorReported;
    }
    set workerErrorReported(handler) {
        if (this._workerErrorReported) {
            this._client.removeListener("ServiceWorker.workerErrorReported", this._workerErrorReported);
        }
        this._workerErrorReported = handler;
        if (handler) {
            this._client.on("ServiceWorker.workerErrorReported", handler);
        }
    }
}
exports.ServiceWorker = ServiceWorker;
class Input {
    constructor(client) {
        this._client = client;
    }
    /** Ignores input events (useful while auditing page). */
    setIgnoreInputEvents(params) {
        return this._client.send("Input.setIgnoreInputEvents", params);
    }
    /** Dispatches a key event to the page. */
    dispatchKeyEvent(params) {
        return this._client.send("Input.dispatchKeyEvent", params);
    }
    /** Dispatches a mouse event to the page. */
    dispatchMouseEvent(params) {
        return this._client.send("Input.dispatchMouseEvent", params);
    }
    /** Dispatches a touch event to the page. */
    dispatchTouchEvent(params) {
        return this._client.send("Input.dispatchTouchEvent", params);
    }
    /** Emulates touch event from the mouse event parameters. */
    emulateTouchFromMouseEvent(params) {
        return this._client.send("Input.emulateTouchFromMouseEvent", params);
    }
    /** Synthesizes a pinch gesture over a time period by issuing appropriate touch events. */
    synthesizePinchGesture(params) {
        return this._client.send("Input.synthesizePinchGesture", params);
    }
    /** Synthesizes a scroll gesture over a time period by issuing appropriate touch events. */
    synthesizeScrollGesture(params) {
        return this._client.send("Input.synthesizeScrollGesture", params);
    }
    /** Synthesizes a tap gesture over a time period by issuing appropriate touch events. */
    synthesizeTapGesture(params) {
        return this._client.send("Input.synthesizeTapGesture", params);
    }
}
exports.Input = Input;
class LayerTree {
    constructor(client) {
        this._layerTreeDidChange = null;
        this._layerPainted = null;
        this._client = client;
    }
    /** Enables compositing tree inspection. */
    enable() {
        return this._client.send("LayerTree.enable");
    }
    /** Disables compositing tree inspection. */
    disable() {
        return this._client.send("LayerTree.disable");
    }
    /** Provides the reasons why the given layer was composited. */
    compositingReasons(params) {
        return this._client.send("LayerTree.compositingReasons", params);
    }
    /** Returns the layer snapshot identifier. */
    makeSnapshot(params) {
        return this._client.send("LayerTree.makeSnapshot", params);
    }
    /** Returns the snapshot identifier. */
    loadSnapshot(params) {
        return this._client.send("LayerTree.loadSnapshot", params);
    }
    /** Releases layer snapshot captured by the back-end. */
    releaseSnapshot(params) {
        return this._client.send("LayerTree.releaseSnapshot", params);
    }
    profileSnapshot(params) {
        return this._client.send("LayerTree.profileSnapshot", params);
    }
    /** Replays the layer snapshot and returns the resulting bitmap. */
    replaySnapshot(params) {
        return this._client.send("LayerTree.replaySnapshot", params);
    }
    /** Replays the layer snapshot and returns canvas log. */
    snapshotCommandLog(params) {
        return this._client.send("LayerTree.snapshotCommandLog", params);
    }
    get layerTreeDidChange() {
        return this._layerTreeDidChange;
    }
    set layerTreeDidChange(handler) {
        if (this._layerTreeDidChange) {
            this._client.removeListener("LayerTree.layerTreeDidChange", this._layerTreeDidChange);
        }
        this._layerTreeDidChange = handler;
        if (handler) {
            this._client.on("LayerTree.layerTreeDidChange", handler);
        }
    }
    get layerPainted() {
        return this._layerPainted;
    }
    set layerPainted(handler) {
        if (this._layerPainted) {
            this._client.removeListener("LayerTree.layerPainted", this._layerPainted);
        }
        this._layerPainted = handler;
        if (handler) {
            this._client.on("LayerTree.layerPainted", handler);
        }
    }
}
exports.LayerTree = LayerTree;
class DeviceOrientation {
    constructor(client) {
        this._client = client;
    }
    /** Overrides the Device Orientation. */
    setDeviceOrientationOverride(params) {
        return this._client.send("DeviceOrientation.setDeviceOrientationOverride", params);
    }
    /** Clears the overridden Device Orientation. */
    clearDeviceOrientationOverride() {
        return this._client.send("DeviceOrientation.clearDeviceOrientationOverride");
    }
}
exports.DeviceOrientation = DeviceOrientation;
class Tracing {
    constructor(client) {
        this._dataCollected = null;
        this._tracingComplete = null;
        this._bufferUsage = null;
        this._client = client;
    }
    /** Start trace events collection. */
    start(params) {
        return this._client.send("Tracing.start", params);
    }
    /** Stop trace events collection. */
    end() {
        return this._client.send("Tracing.end");
    }
    /** Gets supported tracing categories. */
    getCategories() {
        return this._client.send("Tracing.getCategories");
    }
    /** Request a global memory dump. */
    requestMemoryDump() {
        return this._client.send("Tracing.requestMemoryDump");
    }
    /** Record a clock sync marker in the trace. */
    recordClockSyncMarker(params) {
        return this._client.send("Tracing.recordClockSyncMarker", params);
    }
    /** Contains an bucket of collected trace events. When tracing is stopped collected events will be send as a sequence of dataCollected events followed by tracingComplete event. */
    get dataCollected() {
        return this._dataCollected;
    }
    set dataCollected(handler) {
        if (this._dataCollected) {
            this._client.removeListener("Tracing.dataCollected", this._dataCollected);
        }
        this._dataCollected = handler;
        if (handler) {
            this._client.on("Tracing.dataCollected", handler);
        }
    }
    /** Signals that tracing is stopped and there is no trace buffers pending flush, all data were delivered via dataCollected events. */
    get tracingComplete() {
        return this._tracingComplete;
    }
    set tracingComplete(handler) {
        if (this._tracingComplete) {
            this._client.removeListener("Tracing.tracingComplete", this._tracingComplete);
        }
        this._tracingComplete = handler;
        if (handler) {
            this._client.on("Tracing.tracingComplete", handler);
        }
    }
    get bufferUsage() {
        return this._bufferUsage;
    }
    set bufferUsage(handler) {
        if (this._bufferUsage) {
            this._client.removeListener("Tracing.bufferUsage", this._bufferUsage);
        }
        this._bufferUsage = handler;
        if (handler) {
            this._client.on("Tracing.bufferUsage", handler);
        }
    }
}
exports.Tracing = Tracing;
class Animation {
    constructor(client) {
        this._animationCreated = null;
        this._animationStarted = null;
        this._animationCanceled = null;
        this._client = client;
    }
    /** Enables animation domain notifications. */
    enable() {
        return this._client.send("Animation.enable");
    }
    /** Disables animation domain notifications. */
    disable() {
        return this._client.send("Animation.disable");
    }
    /** Gets the playback rate of the document timeline. */
    getPlaybackRate() {
        return this._client.send("Animation.getPlaybackRate");
    }
    /** Sets the playback rate of the document timeline. */
    setPlaybackRate(params) {
        return this._client.send("Animation.setPlaybackRate", params);
    }
    /** Returns the current time of the an animation. */
    getCurrentTime(params) {
        return this._client.send("Animation.getCurrentTime", params);
    }
    /** Sets the paused state of a set of animations. */
    setPaused(params) {
        return this._client.send("Animation.setPaused", params);
    }
    /** Sets the timing of an animation node. */
    setTiming(params) {
        return this._client.send("Animation.setTiming", params);
    }
    /** Seek a set of animations to a particular time within each animation. */
    seekAnimations(params) {
        return this._client.send("Animation.seekAnimations", params);
    }
    /** Releases a set of animations to no longer be manipulated. */
    releaseAnimations(params) {
        return this._client.send("Animation.releaseAnimations", params);
    }
    /** Gets the remote object of the Animation. */
    resolveAnimation(params) {
        return this._client.send("Animation.resolveAnimation", params);
    }
    /** Event for each animation that has been created. */
    get animationCreated() {
        return this._animationCreated;
    }
    set animationCreated(handler) {
        if (this._animationCreated) {
            this._client.removeListener("Animation.animationCreated", this._animationCreated);
        }
        this._animationCreated = handler;
        if (handler) {
            this._client.on("Animation.animationCreated", handler);
        }
    }
    /** Event for animation that has been started. */
    get animationStarted() {
        return this._animationStarted;
    }
    set animationStarted(handler) {
        if (this._animationStarted) {
            this._client.removeListener("Animation.animationStarted", this._animationStarted);
        }
        this._animationStarted = handler;
        if (handler) {
            this._client.on("Animation.animationStarted", handler);
        }
    }
    /** Event for when an animation has been cancelled. */
    get animationCanceled() {
        return this._animationCanceled;
    }
    set animationCanceled(handler) {
        if (this._animationCanceled) {
            this._client.removeListener("Animation.animationCanceled", this._animationCanceled);
        }
        this._animationCanceled = handler;
        if (handler) {
            this._client.on("Animation.animationCanceled", handler);
        }
    }
}
exports.Animation = Animation;
class Accessibility {
    constructor(client) {
        this._client = client;
    }
    /** Fetches the accessibility node and partial accessibility tree for this DOM node, if it exists. */
    getPartialAXTree(params) {
        return this._client.send("Accessibility.getPartialAXTree", params);
    }
}
exports.Accessibility = Accessibility;
class Storage {
    constructor(client) {
        this._cacheStorageListUpdated = null;
        this._cacheStorageContentUpdated = null;
        this._indexedDBListUpdated = null;
        this._indexedDBContentUpdated = null;
        this._client = client;
    }
    /** Clears storage for origin. */
    clearDataForOrigin(params) {
        return this._client.send("Storage.clearDataForOrigin", params);
    }
    /** Returns usage and quota in bytes. */
    getUsageAndQuota(params) {
        return this._client.send("Storage.getUsageAndQuota", params);
    }
    /** Registers origin to be notified when an update occurs to its cache storage list. */
    trackCacheStorageForOrigin(params) {
        return this._client.send("Storage.trackCacheStorageForOrigin", params);
    }
    /** Unregisters origin from receiving notifications for cache storage. */
    untrackCacheStorageForOrigin(params) {
        return this._client.send("Storage.untrackCacheStorageForOrigin", params);
    }
    /** Registers origin to be notified when an update occurs to its IndexedDB. */
    trackIndexedDBForOrigin(params) {
        return this._client.send("Storage.trackIndexedDBForOrigin", params);
    }
    /** Unregisters origin from receiving notifications for IndexedDB. */
    untrackIndexedDBForOrigin(params) {
        return this._client.send("Storage.untrackIndexedDBForOrigin", params);
    }
    /** A cache has been added/deleted. */
    get cacheStorageListUpdated() {
        return this._cacheStorageListUpdated;
    }
    set cacheStorageListUpdated(handler) {
        if (this._cacheStorageListUpdated) {
            this._client.removeListener("Storage.cacheStorageListUpdated", this._cacheStorageListUpdated);
        }
        this._cacheStorageListUpdated = handler;
        if (handler) {
            this._client.on("Storage.cacheStorageListUpdated", handler);
        }
    }
    /** A cache's contents have been modified. */
    get cacheStorageContentUpdated() {
        return this._cacheStorageContentUpdated;
    }
    set cacheStorageContentUpdated(handler) {
        if (this._cacheStorageContentUpdated) {
            this._client.removeListener("Storage.cacheStorageContentUpdated", this._cacheStorageContentUpdated);
        }
        this._cacheStorageContentUpdated = handler;
        if (handler) {
            this._client.on("Storage.cacheStorageContentUpdated", handler);
        }
    }
    /** The origin's IndexedDB database list has been modified. */
    get indexedDBListUpdated() {
        return this._indexedDBListUpdated;
    }
    set indexedDBListUpdated(handler) {
        if (this._indexedDBListUpdated) {
            this._client.removeListener("Storage.indexedDBListUpdated", this._indexedDBListUpdated);
        }
        this._indexedDBListUpdated = handler;
        if (handler) {
            this._client.on("Storage.indexedDBListUpdated", handler);
        }
    }
    /** The origin's IndexedDB object store has been modified. */
    get indexedDBContentUpdated() {
        return this._indexedDBContentUpdated;
    }
    set indexedDBContentUpdated(handler) {
        if (this._indexedDBContentUpdated) {
            this._client.removeListener("Storage.indexedDBContentUpdated", this._indexedDBContentUpdated);
        }
        this._indexedDBContentUpdated = handler;
        if (handler) {
            this._client.on("Storage.indexedDBContentUpdated", handler);
        }
    }
}
exports.Storage = Storage;
/** Provides access to log entries. */
class Log {
    constructor(client) {
        this._entryAdded = null;
        this._client = client;
    }
    /** Enables log domain, sends the entries collected so far to the client by means of the <code>entryAdded</code> notification. */
    enable() {
        return this._client.send("Log.enable");
    }
    /** Disables log domain, prevents further log entries from being reported to the client. */
    disable() {
        return this._client.send("Log.disable");
    }
    /** Clears the log. */
    clear() {
        return this._client.send("Log.clear");
    }
    /** start violation reporting. */
    startViolationsReport(params) {
        return this._client.send("Log.startViolationsReport", params);
    }
    /** Stop violation reporting. */
    stopViolationsReport() {
        return this._client.send("Log.stopViolationsReport");
    }
    /** Issued when new message was logged. */
    get entryAdded() {
        return this._entryAdded;
    }
    set entryAdded(handler) {
        if (this._entryAdded) {
            this._client.removeListener("Log.entryAdded", this._entryAdded);
        }
        this._entryAdded = handler;
        if (handler) {
            this._client.on("Log.entryAdded", handler);
        }
    }
}
exports.Log = Log;
/** The SystemInfo domain defines methods and events for querying low-level system information. */
class SystemInfo {
    constructor(client) {
        this._client = client;
    }
    /** Returns information about the system. */
    getInfo() {
        return this._client.send("SystemInfo.getInfo");
    }
}
exports.SystemInfo = SystemInfo;
/** The Tethering domain defines methods and events for browser port binding. */
class Tethering {
    constructor(client) {
        this._accepted = null;
        this._client = client;
    }
    /** Request browser port binding. */
    bind(params) {
        return this._client.send("Tethering.bind", params);
    }
    /** Request browser port unbinding. */
    unbind(params) {
        return this._client.send("Tethering.unbind", params);
    }
    /** Informs that port was successfully bound and got a specified connection id. */
    get accepted() {
        return this._accepted;
    }
    set accepted(handler) {
        if (this._accepted) {
            this._client.removeListener("Tethering.accepted", this._accepted);
        }
        this._accepted = handler;
        if (handler) {
            this._client.on("Tethering.accepted", handler);
        }
    }
}
exports.Tethering = Tethering;
/** The Browser domain defines methods and events for browser managing. */
class Browser {
    constructor(client) {
        this._client = client;
    }
    /** Close browser gracefully. */
    close() {
        return this._client.send("Browser.close");
    }
    /** Get the browser window that contains the devtools target. */
    getWindowForTarget(params) {
        return this._client.send("Browser.getWindowForTarget", params);
    }
    /** Returns version information. */
    getVersion() {
        return this._client.send("Browser.getVersion");
    }
    /** Set position and/or size of the browser window. */
    setWindowBounds(params) {
        return this._client.send("Browser.setWindowBounds", params);
    }
    /** Get position and size of the browser window. */
    getWindowBounds(params) {
        return this._client.send("Browser.getWindowBounds", params);
    }
}
exports.Browser = Browser;
/** Provides information about the protocol schema. */
class Schema {
    constructor(client) {
        this._client = client;
    }
    /** Returns supported domains. */
    getDomains() {
        return this._client.send("Schema.getDomains");
    }
}
exports.Schema = Schema;
/** Runtime domain exposes JavaScript runtime by means of remote evaluation and mirror objects. Evaluation results are returned as mirror object that expose object type, string representation and unique identifier that can be used for further object reference. Original objects are maintained in memory unless they are either explicitly released or are released along with the other objects in their object group. */
class Runtime {
    constructor(client) {
        this._executionContextCreated = null;
        this._executionContextDestroyed = null;
        this._executionContextsCleared = null;
        this._exceptionThrown = null;
        this._exceptionRevoked = null;
        this._consoleAPICalled = null;
        this._inspectRequested = null;
        this._client = client;
    }
    /** Evaluates expression on global object. */
    evaluate(params) {
        return this._client.send("Runtime.evaluate", params);
    }
    /** Add handler to promise with given promise object id. */
    awaitPromise(params) {
        return this._client.send("Runtime.awaitPromise", params);
    }
    /** Calls function with given declaration on the given object. Object group of the result is inherited from the target object. */
    callFunctionOn(params) {
        return this._client.send("Runtime.callFunctionOn", params);
    }
    /** Returns properties of a given object. Object group of the result is inherited from the target object. */
    getProperties(params) {
        return this._client.send("Runtime.getProperties", params);
    }
    /** Releases remote object with given id. */
    releaseObject(params) {
        return this._client.send("Runtime.releaseObject", params);
    }
    /** Releases all remote objects that belong to a given group. */
    releaseObjectGroup(params) {
        return this._client.send("Runtime.releaseObjectGroup", params);
    }
    /** Tells inspected instance to run if it was waiting for debugger to attach. */
    runIfWaitingForDebugger() {
        return this._client.send("Runtime.runIfWaitingForDebugger");
    }
    /** Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context. */
    enable() {
        return this._client.send("Runtime.enable");
    }
    /** Disables reporting of execution contexts creation. */
    disable() {
        return this._client.send("Runtime.disable");
    }
    /** Discards collected exceptions and console API calls. */
    discardConsoleEntries() {
        return this._client.send("Runtime.discardConsoleEntries");
    }
    setCustomObjectFormatterEnabled(params) {
        return this._client.send("Runtime.setCustomObjectFormatterEnabled", params);
    }
    /** Compiles expression. */
    compileScript(params) {
        return this._client.send("Runtime.compileScript", params);
    }
    /** Runs script with given id in a given context. */
    runScript(params) {
        return this._client.send("Runtime.runScript", params);
    }
    queryObjects(params) {
        return this._client.send("Runtime.queryObjects", params);
    }
    /** Returns all let, const and class variables from global scope. */
    globalLexicalScopeNames(params) {
        return this._client.send("Runtime.globalLexicalScopeNames", params);
    }
    /** Issued when new execution context is created. */
    get executionContextCreated() {
        return this._executionContextCreated;
    }
    set executionContextCreated(handler) {
        if (this._executionContextCreated) {
            this._client.removeListener("Runtime.executionContextCreated", this._executionContextCreated);
        }
        this._executionContextCreated = handler;
        if (handler) {
            this._client.on("Runtime.executionContextCreated", handler);
        }
    }
    /** Issued when execution context is destroyed. */
    get executionContextDestroyed() {
        return this._executionContextDestroyed;
    }
    set executionContextDestroyed(handler) {
        if (this._executionContextDestroyed) {
            this._client.removeListener("Runtime.executionContextDestroyed", this._executionContextDestroyed);
        }
        this._executionContextDestroyed = handler;
        if (handler) {
            this._client.on("Runtime.executionContextDestroyed", handler);
        }
    }
    /** Issued when all executionContexts were cleared in browser */
    get executionContextsCleared() {
        return this._executionContextsCleared;
    }
    set executionContextsCleared(handler) {
        if (this._executionContextsCleared) {
            this._client.removeListener("Runtime.executionContextsCleared", this._executionContextsCleared);
        }
        this._executionContextsCleared = handler;
        if (handler) {
            this._client.on("Runtime.executionContextsCleared", handler);
        }
    }
    /** Issued when exception was thrown and unhandled. */
    get exceptionThrown() {
        return this._exceptionThrown;
    }
    set exceptionThrown(handler) {
        if (this._exceptionThrown) {
            this._client.removeListener("Runtime.exceptionThrown", this._exceptionThrown);
        }
        this._exceptionThrown = handler;
        if (handler) {
            this._client.on("Runtime.exceptionThrown", handler);
        }
    }
    /** Issued when unhandled exception was revoked. */
    get exceptionRevoked() {
        return this._exceptionRevoked;
    }
    set exceptionRevoked(handler) {
        if (this._exceptionRevoked) {
            this._client.removeListener("Runtime.exceptionRevoked", this._exceptionRevoked);
        }
        this._exceptionRevoked = handler;
        if (handler) {
            this._client.on("Runtime.exceptionRevoked", handler);
        }
    }
    /** Issued when console API was called. */
    get consoleAPICalled() {
        return this._consoleAPICalled;
    }
    set consoleAPICalled(handler) {
        if (this._consoleAPICalled) {
            this._client.removeListener("Runtime.consoleAPICalled", this._consoleAPICalled);
        }
        this._consoleAPICalled = handler;
        if (handler) {
            this._client.on("Runtime.consoleAPICalled", handler);
        }
    }
    /** Issued when object should be inspected (for example, as a result of inspect() command line API call). */
    get inspectRequested() {
        return this._inspectRequested;
    }
    set inspectRequested(handler) {
        if (this._inspectRequested) {
            this._client.removeListener("Runtime.inspectRequested", this._inspectRequested);
        }
        this._inspectRequested = handler;
        if (handler) {
            this._client.on("Runtime.inspectRequested", handler);
        }
    }
}
exports.Runtime = Runtime;
/** Debugger domain exposes JavaScript debugging capabilities. It allows setting and removing breakpoints, stepping through execution, exploring stack traces, etc. */
class Debugger {
    constructor(client) {
        this._scriptParsed = null;
        this._scriptFailedToParse = null;
        this._breakpointResolved = null;
        this._paused = null;
        this._resumed = null;
        this._client = client;
    }
    /** Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received. */
    enable() {
        return this._client.send("Debugger.enable");
    }
    /** Disables debugger for given page. */
    disable() {
        return this._client.send("Debugger.disable");
    }
    /** Activates / deactivates all breakpoints on the page. */
    setBreakpointsActive(params) {
        return this._client.send("Debugger.setBreakpointsActive", params);
    }
    /** Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc). */
    setSkipAllPauses(params) {
        return this._client.send("Debugger.setSkipAllPauses", params);
    }
    /** Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads. */
    setBreakpointByUrl(params) {
        return this._client.send("Debugger.setBreakpointByUrl", params);
    }
    /** Sets JavaScript breakpoint at a given location. */
    setBreakpoint(params) {
        return this._client.send("Debugger.setBreakpoint", params);
    }
    /** Removes JavaScript breakpoint. */
    removeBreakpoint(params) {
        return this._client.send("Debugger.removeBreakpoint", params);
    }
    /** Returns possible locations for breakpoint. scriptId in start and end range locations should be the same. */
    getPossibleBreakpoints(params) {
        return this._client.send("Debugger.getPossibleBreakpoints", params);
    }
    /** Continues execution until specific location is reached. */
    continueToLocation(params) {
        return this._client.send("Debugger.continueToLocation", params);
    }
    pauseOnAsyncTask(params) {
        return this._client.send("Debugger.pauseOnAsyncTask", params);
    }
    /** Steps over the statement. */
    stepOver() {
        return this._client.send("Debugger.stepOver");
    }
    /** Steps into the function call. */
    stepInto(params) {
        return this._client.send("Debugger.stepInto", params);
    }
    /** Steps out of the function call. */
    stepOut() {
        return this._client.send("Debugger.stepOut");
    }
    /** Stops on the next JavaScript statement. */
    pause() {
        return this._client.send("Debugger.pause");
    }
    /** This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called. */
    scheduleStepIntoAsync() {
        return this._client.send("Debugger.scheduleStepIntoAsync");
    }
    /** Resumes JavaScript execution. */
    resume() {
        return this._client.send("Debugger.resume");
    }
    /** Searches for given string in script content. */
    searchInContent(params) {
        return this._client.send("Debugger.searchInContent", params);
    }
    /** Edits JavaScript source live. */
    setScriptSource(params) {
        return this._client.send("Debugger.setScriptSource", params);
    }
    /** Restarts particular call frame from the beginning. */
    restartFrame(params) {
        return this._client.send("Debugger.restartFrame", params);
    }
    /** Returns source for the script with given id. */
    getScriptSource(params) {
        return this._client.send("Debugger.getScriptSource", params);
    }
    /** Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>. */
    setPauseOnExceptions(params) {
        return this._client.send("Debugger.setPauseOnExceptions", params);
    }
    /** Evaluates expression on a given call frame. */
    evaluateOnCallFrame(params) {
        return this._client.send("Debugger.evaluateOnCallFrame", params);
    }
    /** Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually. */
    setVariableValue(params) {
        return this._client.send("Debugger.setVariableValue", params);
    }
    /** Changes return value in top frame. Available only at return break position. */
    setReturnValue(params) {
        return this._client.send("Debugger.setReturnValue", params);
    }
    /** Enables or disables async call stacks tracking. */
    setAsyncCallStackDepth(params) {
        return this._client.send("Debugger.setAsyncCallStackDepth", params);
    }
    /** Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. */
    setBlackboxPatterns(params) {
        return this._client.send("Debugger.setBlackboxPatterns", params);
    }
    /** Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted. */
    setBlackboxedRanges(params) {
        return this._client.send("Debugger.setBlackboxedRanges", params);
    }
    /** Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger. */
    get scriptParsed() {
        return this._scriptParsed;
    }
    set scriptParsed(handler) {
        if (this._scriptParsed) {
            this._client.removeListener("Debugger.scriptParsed", this._scriptParsed);
        }
        this._scriptParsed = handler;
        if (handler) {
            this._client.on("Debugger.scriptParsed", handler);
        }
    }
    /** Fired when virtual machine fails to parse the script. */
    get scriptFailedToParse() {
        return this._scriptFailedToParse;
    }
    set scriptFailedToParse(handler) {
        if (this._scriptFailedToParse) {
            this._client.removeListener("Debugger.scriptFailedToParse", this._scriptFailedToParse);
        }
        this._scriptFailedToParse = handler;
        if (handler) {
            this._client.on("Debugger.scriptFailedToParse", handler);
        }
    }
    /** Fired when breakpoint is resolved to an actual script and location. */
    get breakpointResolved() {
        return this._breakpointResolved;
    }
    set breakpointResolved(handler) {
        if (this._breakpointResolved) {
            this._client.removeListener("Debugger.breakpointResolved", this._breakpointResolved);
        }
        this._breakpointResolved = handler;
        if (handler) {
            this._client.on("Debugger.breakpointResolved", handler);
        }
    }
    /** Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria. */
    get paused() {
        return this._paused;
    }
    set paused(handler) {
        if (this._paused) {
            this._client.removeListener("Debugger.paused", this._paused);
        }
        this._paused = handler;
        if (handler) {
            this._client.on("Debugger.paused", handler);
        }
    }
    /** Fired when the virtual machine resumed execution. */
    get resumed() {
        return this._resumed;
    }
    set resumed(handler) {
        if (this._resumed) {
            this._client.removeListener("Debugger.resumed", this._resumed);
        }
        this._resumed = handler;
        if (handler) {
            this._client.on("Debugger.resumed", handler);
        }
    }
}
exports.Debugger = Debugger;
/** This domain is deprecated - use Runtime or Log instead. */
class Console {
    constructor(client) {
        this._messageAdded = null;
        this._client = client;
    }
    /** Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification. */
    enable() {
        return this._client.send("Console.enable");
    }
    /** Disables console domain, prevents further console messages from being reported to the client. */
    disable() {
        return this._client.send("Console.disable");
    }
    /** Does nothing. */
    clearMessages() {
        return this._client.send("Console.clearMessages");
    }
    /** Issued when new console message is added. */
    get messageAdded() {
        return this._messageAdded;
    }
    set messageAdded(handler) {
        if (this._messageAdded) {
            this._client.removeListener("Console.messageAdded", this._messageAdded);
        }
        this._messageAdded = handler;
        if (handler) {
            this._client.on("Console.messageAdded", handler);
        }
    }
}
exports.Console = Console;
class Profiler {
    constructor(client) {
        this._consoleProfileStarted = null;
        this._consoleProfileFinished = null;
        this._client = client;
    }
    enable() {
        return this._client.send("Profiler.enable");
    }
    disable() {
        return this._client.send("Profiler.disable");
    }
    /** Changes CPU profiler sampling interval. Must be called before CPU profiles recording started. */
    setSamplingInterval(params) {
        return this._client.send("Profiler.setSamplingInterval", params);
    }
    start() {
        return this._client.send("Profiler.start");
    }
    stop() {
        return this._client.send("Profiler.stop");
    }
    /** Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters. */
    startPreciseCoverage(params) {
        return this._client.send("Profiler.startPreciseCoverage", params);
    }
    /** Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code. */
    stopPreciseCoverage() {
        return this._client.send("Profiler.stopPreciseCoverage");
    }
    /** Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started. */
    takePreciseCoverage() {
        return this._client.send("Profiler.takePreciseCoverage");
    }
    /** Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection. */
    getBestEffortCoverage() {
        return this._client.send("Profiler.getBestEffortCoverage");
    }
    /** Enable type profile. */
    startTypeProfile() {
        return this._client.send("Profiler.startTypeProfile");
    }
    /** Disable type profile. Disabling releases type profile data collected so far. */
    stopTypeProfile() {
        return this._client.send("Profiler.stopTypeProfile");
    }
    /** Collect type profile. */
    takeTypeProfile() {
        return this._client.send("Profiler.takeTypeProfile");
    }
    /** Sent when new profile recording is started using console.profile() call. */
    get consoleProfileStarted() {
        return this._consoleProfileStarted;
    }
    set consoleProfileStarted(handler) {
        if (this._consoleProfileStarted) {
            this._client.removeListener("Profiler.consoleProfileStarted", this._consoleProfileStarted);
        }
        this._consoleProfileStarted = handler;
        if (handler) {
            this._client.on("Profiler.consoleProfileStarted", handler);
        }
    }
    get consoleProfileFinished() {
        return this._consoleProfileFinished;
    }
    set consoleProfileFinished(handler) {
        if (this._consoleProfileFinished) {
            this._client.removeListener("Profiler.consoleProfileFinished", this._consoleProfileFinished);
        }
        this._consoleProfileFinished = handler;
        if (handler) {
            this._client.on("Profiler.consoleProfileFinished", handler);
        }
    }
}
exports.Profiler = Profiler;
class HeapProfiler {
    constructor(client) {
        this._addHeapSnapshotChunk = null;
        this._resetProfiles = null;
        this._reportHeapSnapshotProgress = null;
        this._lastSeenObjectId = null;
        this._heapStatsUpdate = null;
        this._client = client;
    }
    enable() {
        return this._client.send("HeapProfiler.enable");
    }
    disable() {
        return this._client.send("HeapProfiler.disable");
    }
    startTrackingHeapObjects(params) {
        return this._client.send("HeapProfiler.startTrackingHeapObjects", params);
    }
    stopTrackingHeapObjects(params) {
        return this._client.send("HeapProfiler.stopTrackingHeapObjects", params);
    }
    takeHeapSnapshot(params) {
        return this._client.send("HeapProfiler.takeHeapSnapshot", params);
    }
    collectGarbage() {
        return this._client.send("HeapProfiler.collectGarbage");
    }
    getObjectByHeapObjectId(params) {
        return this._client.send("HeapProfiler.getObjectByHeapObjectId", params);
    }
    /** Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions). */
    addInspectedHeapObject(params) {
        return this._client.send("HeapProfiler.addInspectedHeapObject", params);
    }
    getHeapObjectId(params) {
        return this._client.send("HeapProfiler.getHeapObjectId", params);
    }
    startSampling(params) {
        return this._client.send("HeapProfiler.startSampling", params);
    }
    stopSampling() {
        return this._client.send("HeapProfiler.stopSampling");
    }
    getSamplingProfile() {
        return this._client.send("HeapProfiler.getSamplingProfile");
    }
    get addHeapSnapshotChunk() {
        return this._addHeapSnapshotChunk;
    }
    set addHeapSnapshotChunk(handler) {
        if (this._addHeapSnapshotChunk) {
            this._client.removeListener("HeapProfiler.addHeapSnapshotChunk", this._addHeapSnapshotChunk);
        }
        this._addHeapSnapshotChunk = handler;
        if (handler) {
            this._client.on("HeapProfiler.addHeapSnapshotChunk", handler);
        }
    }
    get resetProfiles() {
        return this._resetProfiles;
    }
    set resetProfiles(handler) {
        if (this._resetProfiles) {
            this._client.removeListener("HeapProfiler.resetProfiles", this._resetProfiles);
        }
        this._resetProfiles = handler;
        if (handler) {
            this._client.on("HeapProfiler.resetProfiles", handler);
        }
    }
    get reportHeapSnapshotProgress() {
        return this._reportHeapSnapshotProgress;
    }
    set reportHeapSnapshotProgress(handler) {
        if (this._reportHeapSnapshotProgress) {
            this._client.removeListener("HeapProfiler.reportHeapSnapshotProgress", this._reportHeapSnapshotProgress);
        }
        this._reportHeapSnapshotProgress = handler;
        if (handler) {
            this._client.on("HeapProfiler.reportHeapSnapshotProgress", handler);
        }
    }
    /** If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event. */
    get lastSeenObjectId() {
        return this._lastSeenObjectId;
    }
    set lastSeenObjectId(handler) {
        if (this._lastSeenObjectId) {
            this._client.removeListener("HeapProfiler.lastSeenObjectId", this._lastSeenObjectId);
        }
        this._lastSeenObjectId = handler;
        if (handler) {
            this._client.on("HeapProfiler.lastSeenObjectId", handler);
        }
    }
    /** If heap objects tracking has been started then backend may send update for one or more fragments */
    get heapStatsUpdate() {
        return this._heapStatsUpdate;
    }
    set heapStatsUpdate(handler) {
        if (this._heapStatsUpdate) {
            this._client.removeListener("HeapProfiler.heapStatsUpdate", this._heapStatsUpdate);
        }
        this._heapStatsUpdate = handler;
        if (handler) {
            this._client.on("HeapProfiler.heapStatsUpdate", handler);
        }
    }
}
exports.HeapProfiler = HeapProfiler;
//# sourceMappingURL=tot.js.map